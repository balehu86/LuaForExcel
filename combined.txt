' ============================================
' WorkbookRuntime.cls - 工作簿运行时
' ============================================
' 设计原因：
' 1. 每个 Workbook 一个实例
' 2. 封装 Lua VM、TaskTable、协程调度
' 3. 实现 CanRun等接口，供调度器驱动
' 4. 处理热更新（模块级，非 VM 级）
' ============================================

Option Explicit

' ===== Lua 5.4 API 声明 =====
#If VBA7 Then
    Private Declare PtrSafe Function luaL_newstate Lib "lua54.dll" () As LongPtr
    Private Declare PtrSafe Sub luaL_openlibs Lib "lua54.dll" (ByVal L As LongPtr)
    Private Declare PtrSafe Sub lua_close Lib "lua54.dll" (ByVal L As LongPtr)
    Private Declare PtrSafe Function luaL_loadstring Lib "lua54.dll" (ByVal L As LongPtr, ByVal s As String) As Long
    Private Declare PtrSafe Function lua_pcallk Lib "lua54.dll" (ByVal L As LongPtr, ByVal nargs As Long, ByVal nResults As Long, ByVal msgh As Long, ByVal ctx As LongPtr, ByVal k As LongPtr) As Long
    Private Declare PtrSafe Function lua_tonumberx Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal isnum As LongPtr) As Double
    Private Declare PtrSafe Function lua_tolstring Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal leng As LongPtr) As LongPtr
    Private Declare PtrSafe Function lua_toboolean Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long) As Long
    Private Declare PtrSafe Function lua_type Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long) As Long
    Private Declare PtrSafe Sub lua_pushnil Lib "lua54.dll" (ByVal L As LongPtr)
    Private Declare PtrSafe Sub lua_pushnumber Lib "lua54.dll" (ByVal L As LongPtr, ByVal n As Double)
    Private Declare PtrSafe Sub lua_pushstring Lib "lua54.dll" (ByVal L As LongPtr, ByVal s As String)
    Private Declare PtrSafe Sub lua_pushboolean Lib "lua54.dll" (ByVal L As LongPtr, ByVal b As Long)
    Private Declare PtrSafe Function lua_gettop Lib "lua54.dll" (ByVal L As LongPtr) As Long
    Private Declare PtrSafe Sub lua_settop Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long)
    Private Declare PtrSafe Function lua_getglobal Lib "lua54.dll" (ByVal L As LongPtr, ByVal name As String) As Long
    Private Declare PtrSafe Sub lua_createtable Lib "lua54.dll" (ByVal L As LongPtr, ByVal narr As Long, ByVal nrec As Long)
    Private Declare PtrSafe Sub lua_rawseti Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal n As LongPtr)
    Private Declare PtrSafe Function lua_rawgeti Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal n As LongPtr) As Long
    Private Declare PtrSafe Function lua_rawlen Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long) As LongPtr
    Private Declare PtrSafe Function luaL_loadfilex Lib "lua54.dll" (ByVal L As LongPtr, ByVal filename As String, ByVal mode As LongPtr) As Long
    Private Declare PtrSafe Sub lua_setglobal Lib "lua54.dll" (ByVal L As LongPtr, ByVal name As String)
    Private Declare PtrSafe Function lua_next Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long) As Long
    Private Declare PtrSafe Sub lua_pushvalue Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long)
    Private Declare PtrSafe Function lua_getfield Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal k As String) As Long
    Private Declare PtrSafe Sub lua_setfield Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal k As String)

        ' 协程 API
    Private Declare PtrSafe Function lua_newthread Lib "lua54.dll" (ByVal L As LongPtr) As LongPtr
    Private Declare PtrSafe Function lua_resume Lib "lua54.dll" (ByVal L As LongPtr, ByVal from As LongPtr, ByVal narg As Long, ByVal nres As LongPtr) As Long
    Private Declare PtrSafe Function lua_status Lib "lua54.dll" (ByVal L As LongPtr) As Long
    Private Declare PtrSafe Sub lua_xmove Lib "lua54.dll" (ByVal fromL As LongPtr, ByVal toL As LongPtr, ByVal n As Long)
    ' 系统 API
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal length As LongPtr)
#End if

' Lua 类型常量
Private Const LUA_TNIL = 0
Private Const LUA_TBOOLEAN = 1
Private Const LUA_TNUMBER = 3
Private Const LUA_TSTRING = 4
Private Const LUA_TTABLE = 5
Private Const LUA_TFUNCTION = 6
Private Const LUA_OK = 0
Private Const LUA_YIELD = 1
Private Const LUA_ERRRUN = 2
' 运行时状态（私有，外部不可访问）
Private m_LuaState As LongPtr
Private m_Workbook As Workbook
Private m_WorkbookKey As String
Private m_LastModified As Date
' 路径管理
Private m_SystemMainPath As String      ' 系统 main.lua 路径
Private m_FunctionsPath As String       ' 工作簿 functions.lua 路径
Private m_LastMainModified As Date      ' main.lua 最后修改时间
Private m_LastFunctionsModified As Date ' functions.lua 最后修改时间
' Task 管理（私有 Dictionary）
Private m_TaskTable As Object          ' taskId → Task 数据字典
Private m_ActiveQueue As Object        ' taskId → True（活跃任务）
Private m_RoundRobinCursor As Long
' 配置
Private m_MaxTasksPerTick As Long
Private m_HotReloadEnabled As Boolean
' 配置常量
Private Const DEFAULT_MAX_TASKS_PER_TICK As Long = 1
Private Const DEFAULT_HOT_RELOAD_ENABLED As Boolean = True

' ====初始化与清理====
Private Sub Class_Initialize()
    ' 创建 Lua VM
    m_LuaState = luaL_newstate()
    If m_LuaState = 0 Then
        Err.Raise vbObjectError + 1, , "无法创建 Lua VM"
    End If
    luaL_openlibs m_LuaState
    
    ' 初始化 Task 管理
    Set m_TaskTable = CreateObject("Scripting.Dictionary")
    Set m_ActiveQueue = CreateObject("Scripting.Dictionary")
    m_RoundRobinCursor = 0
    
    ' 配置
    m_MaxTasksPerTick = DEFAULT_MAX_TASKS_PER_TICK
    m_HotReloadEnabled = DEFAULT_HOT_RELOAD_ENABLED
    m_LastModified = #1/1/1900#
End Sub
' 绑定工作簿
Public Sub BindWorkbook(wb As Workbook)
    Set m_Workbook = wb
    m_WorkbookKey = CoreRegistry.GetWorkbookKey(wb)
    
    ' 设置路径
    ' 假设系统路径为："C:\lua\main.lua"
    m_SystemMainPath = "C:\Lua\LuaForExcel\main.lua"
    m_FunctionsPath = wb.Path & "\functions.lua"
    
    ' 初始化修改时间
    m_LastMainModified = #1/1/1900#
    m_LastFunctionsModified = #1/1/1900#
    
    ' 首次加载
    InitialLoadLuaFiles
End Sub

' ====对Scheduler的接口====
Public Function HasRunnable() As Boolean
    HasRunnable = (m_ActiveQueue.Count > 0)
End Function

Public Sub Tick()
    On Error GoTo ErrorHandler

    If m_ActiveQueue Is Nothing Or m_ActiveQueue.Count = 0 Then Exit Sub

    CheckHotReload

    ' 快照活跃任务
    Dim taskIds() As Variant
    ReDim taskIds(0 To m_ActiveQueue.Count - 1)

    Dim idx As Long
    Dim taskId As Variant
    idx = 0
    For Each taskId In m_ActiveQueue.Keys
        taskIds(idx) = taskId
        idx = idx + 1
    Next

    Dim total As Long
    total = UBound(taskIds) + 1
    If total = 0 Then Exit Sub

    ' Round-Robin 调度
    Dim executed As Long
    executed = 0

    Dim cur As Long
    cur = m_RoundRobinCursor Mod total

    Dim toRemove As Object
    Set toRemove = CreateObject("System.Collections.ArrayList")

    Do While executed < m_MaxTasksPerTick And executed < total
        taskId = taskIds(cur)

        If m_TaskTable.Exists(CStr(taskId)) Then
            ResumeTask CStr(taskId)
            executed = executed + 1

            Dim task As Object
            Set task = m_TaskTable(taskId)

            If task("status") = "done" Or task("status") = "error" Then
                toRemove.Add taskId
            End If
        Else
            toRemove.Add taskId
        End If

        cur = (cur + 1) Mod total
    Loop

    ' ===== 修复：在删除前更新游标 =====
    m_RoundRobinCursor = cur
    
    ' 如果游标超出范围，重置为 0
    If m_RoundRobinCursor >= total Then
        m_RoundRobinCursor = 0
    End If

    ' 清理非活跃任务
    Dim i As Long
    For i = 0 To toRemove.Count - 1
        If m_ActiveQueue.Exists(toRemove(i)) Then
            m_ActiveQueue.Remove toRemove(i)
        End If
    Next i

    Exit Sub

ErrorHandler:
    Debug.Print "[WorkbookRuntime.Tick] Error: " & Err.Description
End Sub

' ====公共方法（供 UDF/菜单调用）====
' 创建任务
Public Function CreateTask(cellAddr As String, funcName As String, _
                          startArgs As Variant, resumeSpec As Variant) As String
    ' 生成 taskId
    Dim taskId As String
    taskId = Scheduler.GenerateTaskId(m_WorkbookKey, cellAddr)
    
    ' 创建 Task 数据字典
    Dim task As Object
    Set task = CreateObject("Scripting.Dictionary")
    task("funcName") = funcName
    task("cellAddr") = cellAddr
    task("startArgs") = startArgs
    task("resumeSpec") = resumeSpec
    task("status") = "defined"
    task("progress") = 0
    task("message") = Empty
    task("value") = Empty
    task("error") = ""
    task("coThread") = 0
    
    m_TaskTable(taskId) = task
    
    ' 注册到全局路由表（包含 cellAddr 索引）
    CoreRegistry.RegisterTask taskId, Me, cellAddr
    
    CreateTask = taskId
End Function
' 启动任务
Public Sub StartTask(taskId As String)
    If Not m_TaskTable.Exists(taskId) Then
        Err.Raise vbObjectError + 2, , "任务不存在"
    End If
    
    Dim task As Object
    Set task = m_TaskTable(taskId)
    
    If task("status") <> "defined" Then
        Err.Raise vbObjectError + 3, , "任务状态不是 defined"
    End If
    
    ' 创建协程
    Dim coThread As LongPtr
    coThread = lua_newthread(m_LuaState)
    If coThread = 0 Then
        task("status") = "error"
        task("error") = "无法创建协程"
        Exit Sub
    End If
    task("coThread") = coThread
    
    ' 获取函数
    lua_getglobal m_LuaState, task("funcName")
    If lua_type(m_LuaState, -1) <> LUA_TFUNCTION Then
        task("status") = "error"
        task("error") = "函数不存在: " & task("funcName")
        lua_settop m_LuaState, 0
        Exit Sub
    End If
    
    ' 移动函数到协程
    lua_xmove m_LuaState, coThread, 1
    
    ' 推入 cellAddr
    lua_pushstring coThread, task("cellAddr")
    
    ' 推入启动参数
    Dim nargs As Long
    nargs = 1
    If IsArray(task("startArgs")) Then
        Dim i As Long
        For i = LBound(task("startArgs")) To UBound(task("startArgs"))
            PushValue coThread, task("startArgs")(i)
            nargs = nargs + 1
        Next
    End If
    
    ' 首次 resume
    Dim nres As LongPtr
    Dim result As Long
    result = lua_resume(coThread, m_LuaState, nargs, VarPtr(nres))
    
    HandleResumeResult taskId, result, CLng(nres)
    
    ' 加入活跃队列
    If task("status") = "yielded" Then
        m_ActiveQueue(taskId) = True
        Scheduler.StartScheduler
    End If
End Sub
' 获取任务字段
Public Function GetTaskField(taskId As String, field As String) As Variant
    If Not m_TaskTable.Exists(taskId) Then
        GetTaskField = "#ERROR: 任务不存在"
        Exit Function
    End If
    
    Dim task As Object
    Set task = m_TaskTable(taskId)
    
    Select Case LCase(field)
        Case "status": GetTaskField = task("status")
        Case "progress": GetTaskField = task("progress")
        Case "message": GetTaskField = task("message")
        Case "value": GetTaskField = task("value")
        Case "error": GetTaskField = task("error")
        Case Else: GetTaskField = "#ERROR: 未知字段"
    End Select
End Function
' 暂停任务
Public Sub PauseTask(taskId As String)
    If m_ActiveQueue.Exists(taskId) Then
        m_ActiveQueue.Remove taskId
        m_TaskTable(taskId)("status") = "paused"
    End If
End Sub
' 恢复任务
Public Sub ResumeTaskManual(taskId As String)
    If Not m_TaskTable.Exists(taskId) Then Exit Sub
    
    Dim task As Object
    Set task = m_TaskTable(taskId)
    
    If task("status") = "yielded" Or task("status") = "paused" Then
        If Not m_ActiveQueue.Exists(taskId) Then
            m_ActiveQueue(taskId) = True
            Scheduler.StartScheduler
        End If
    End If
End Sub
' 终止任务
Public Sub TerminateTask(taskId As String)
    If Not m_TaskTable.Exists(taskId) Then Exit Sub
    
    ' 获取 cellAddr
    Dim task As Object
    Set task = m_TaskTable(taskId)
    Dim cellAddr As String
    cellAddr = task("cellAddr")
    
    ' 从活跃队列移除
    If m_ActiveQueue.Exists(taskId) Then
        m_ActiveQueue.Remove taskId
    End If
    
    ' 从任务表移除
    m_TaskTable.Remove taskId
    
    ' 从全局路由表注销（包含 cellAddr 索引）
    CoreRegistry.UnregisterTask taskId, cellAddr
End Sub
' 释放运行时资源
Public Sub Dispose()
    On Error Resume Next
    
    If m_LuaState <> 0 Then
        lua_close m_LuaState
        m_LuaState = 0
    End If
    
    m_TaskTable.RemoveAll
    m_ActiveQueue.RemoveAll
    
    Set m_TaskTable = Nothing
    Set m_ActiveQueue = Nothing
End Sub

' ====LuaEval LuaGet 调用接口====
' 执行 Lua 表达式
Public Function EvalExpression(expression As String) As Variant
    On Error GoTo ErrorHandler
    
    ' 检查热重载
    CheckHotReload
    
    ' 构造代码
    Dim fullCode As String
    fullCode = "return " & expression
    
    ' 加载代码
    Dim result As Long
    result = luaL_loadstring(m_LuaState, fullCode)
    If result <> 0 Then
        EvalExpression = "#LUA_SYNTAX_ERROR: " & GetStringFromState(m_LuaState, -1)
        lua_settop m_LuaState, 0
        Exit Function
    End If
    
    ' 执行代码
    result = lua_pcallk(m_LuaState, 0, 1, 0, 0, 0)
    If result <> 0 Then
        EvalExpression = "#LUA_RUNTIME_ERROR: " & GetStringFromState(m_LuaState, -1)
        lua_settop m_LuaState, 0
        Exit Function
    End If
    
    ' 获取结果
    EvalExpression = GetValue(m_LuaState, -1)
    lua_settop m_LuaState, 0
    Exit Function

ErrorHandler:
    EvalExpression = "#VBA_ERROR: " & Err.Description
    On Error Resume Next
    If m_LuaState <> 0 Then lua_settop m_LuaState, 0
End Function
' 调用 functions.lua 中的函数
Public Function CallFunction(funcName As String, args As Variant) As Variant
    On Error GoTo ErrorHandler
    
    ' 检查热重载
    CheckHotReload
    
    ' 获取函数
    lua_getglobal m_LuaState, funcName
    If lua_type(m_LuaState, -1) <> LUA_TFUNCTION Then
        lua_settop m_LuaState, 0
        CallFunction = "ERROR: 函数 '" & funcName & "' 不存在"
        Exit Function
    End If
    
    ' 推入参数
    Dim i As Long, argCount As Long
    argCount = 0
    For i = LBound(args) To UBound(args)
        PushValue m_LuaState, args(i)
        argCount = argCount + 1
    Next

    ' 调用函数
    Dim result As Long
    result = lua_pcallk(m_LuaState, argCount, -1, 0, 0, 0)
    If result <> 0 Then
        CallFunction = "#LUA_ERROR: " & GetStringFromState(m_LuaState, -1)
        lua_settop m_LuaState, 0
        Exit Function
    End If
    
    ' 处理返回值
    Dim nResults As Long
    nResults = lua_gettop(m_LuaState)
    
    If nResults = 0 Then
        CallFunction = Empty
    ElseIf nResults = 1 Then
        CallFunction = GetValue(m_LuaState, -1)
    Else
        ' 多个返回值 - 返回为水平数组
        Dim results() As Variant
        ReDim results(1 To 1, 1 To nResults)
        For i = 1 To nResults
            results(1, i) = GetValue(m_LuaState, i)
        Next i
        CallFunction = results
    End If
    
    lua_settop m_LuaState, 0
    Exit Function

ErrorHandler:
    CallFunction = "#VBA_ERROR: " & Err.Description
    On Error Resume Next
    If m_LuaState <> 0 Then lua_settop m_LuaState, 0
End Function

' ====Lua热更新（模块级）====
' 初始加载（工作簿打开时）
Private Sub InitialLoadLuaFiles()
    On Error Resume Next
    
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    ' 加载系统 main.lua（必需）
    If fso.FileExists(m_SystemMainPath) Then
        If Not LoadLuaFile(m_SystemMainPath, "main") Then
            MsgBox "警告：系统 main.lua 加载失败" & vbCrLf & _
                   "路径：" & m_SystemMainPath, _
                   vbExclamation, "初始化警告"
        Else
            m_LastMainModified = FileDateTime(m_SystemMainPath)
        End If
    Else
        MsgBox "错误：找不到系统 main.lua" & vbCrLf & _
               "路径：" & m_SystemMainPath, _
               vbCritical, "初始化失败"
    End If
    
    ' 加载工作簿 functions.lua（可选）
    If fso.FileExists(m_FunctionsPath) Then
        If LoadLuaFile(m_FunctionsPath, "functions") Then
            m_LastFunctionsModified = FileDateTime(m_FunctionsPath)
        End If
    End If
End Sub
' 热更新检查（在 Tick 中调用）
Private Sub CheckHotReload()
    If Not m_HotReloadEnabled Then Exit Sub
    
    On Error Resume Next
    
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    ' 检查 main.lua
    If fso.FileExists(m_SystemMainPath) Then
        Dim currentMainModified As Date
        currentMainModified = FileDateTime(m_SystemMainPath)
        
        If currentMainModified <> m_LastMainModified Then
            If ReloadLuaFile(m_SystemMainPath, "main") Then
                m_LastMainModified = currentMainModified
                Debug.Print "[HotReload] main.lua 已更新"
            End If
        End If
    End If
    
    ' 检查 functions.lua
    If fso.FileExists(m_FunctionsPath) Then
        Dim currentFunctionsModified As Date
        currentFunctionsModified = FileDateTime(m_FunctionsPath)
        
        If currentFunctionsModified <> m_LastFunctionsModified Then
            If ReloadLuaFile(m_FunctionsPath, "functions") Then
                m_LastFunctionsModified = currentFunctionsModified
                Debug.Print "[HotReload] functions.lua 已更新"
            End If
        End If
    End If
End Sub
' 手动重载接口
' 重载 functions.lua
Public Function ReloadFunctions() As Boolean
    ReloadFunctions = ReloadLuaFile(m_FunctionsPath, "functions")
    If ReloadFunctions Then
        m_LastFunctionsModified = FileDateTime(m_FunctionsPath)
    End If
End Function
' 重载 main.lua（管理员操作）
Public Function ReloadMainLua() As Boolean
    ReloadMainLua = ReloadLuaFile(m_SystemMainPath, "main")
    If ReloadMainLua Then
        m_LastMainModified = FileDateTime(m_SystemMainPath)
    End If
End Function
' 加载 Lua 文件（无验证，用于初始加载）
Private Function LoadLuaFile(filePath As String, moduleName As String) As Boolean
    On Error GoTo ErrorHandler
    
    Dim result As Long
    result = luaL_loadfilex(m_LuaState, filePath, 0)
    If result = 0 Then result = lua_pcallk(m_LuaState, 0, 0, 0, 0, 0)
    
    If result <> 0 Then
        Dim errMsg As String
        errMsg = GetStringFromState(m_LuaState, -1)
        lua_settop m_LuaState, 0
        
        Debug.Print "[LoadError] " & moduleName & ": " & errMsg
        LoadLuaFile = False
        Exit Function
    End If
    
    LoadLuaFile = True
    Exit Function
    
ErrorHandler:
    Debug.Print "[LoadError] VBA Error: " & Err.Description
    LoadLuaFile = False
End Function
' 重载 Lua 文件（带验证）
Private Function ReloadLuaFile(filePath As String, moduleName As String) As Boolean
    On Error GoTo ErrorHandler
    
    ' ===== 第一步：在临时状态中验证语法 =====
    Dim tempL As LongPtr
    tempL = luaL_newstate()
    If tempL = 0 Then
        ReloadLuaFile = False
        Exit Function
    End If
    
    luaL_openlibs tempL
    
    ' 验证加载
    Dim result As Long
    result = luaL_loadfilex(tempL, filePath, 0)
    If result = 0 Then result = lua_pcallk(tempL, 0, 0, 0, 0, 0)
    
    If result <> 0 Then
        Dim errMsg As String
        errMsg = GetStringFromState(tempL, -1)
        lua_close tempL
        
        MsgBox moduleName & ".lua 存在语法错误：" & vbCrLf & vbCrLf & _
               errMsg & vbCrLf & vbCrLf & _
               "旧版本将继续使用", _
               vbCritical, "热更新失败"
        
        ReloadLuaFile = False
        Exit Function
    End If
    
    lua_close tempL
    
    ' ===== 第二步：清除旧模块缓存 =====
    ' package.loaded[moduleName] = nil
    lua_getglobal m_LuaState, "package"
    lua_getfield m_LuaState, -1, "loaded"
    lua_pushnil m_LuaState
    lua_setfield m_LuaState, -2, moduleName
    lua_settop m_LuaState, 0
    
    ' ===== 第三步：在主状态中重新加载 =====
    result = luaL_loadfilex(m_LuaState, filePath, 0)
    If result = 0 Then result = lua_pcallk(m_LuaState, 0, 0, 0, 0, 0)
    
    If result <> 0 Then
        errMsg = GetStringFromState(m_LuaState, -1)
        lua_settop m_LuaState, 0
        
        MsgBox "主状态加载 " & moduleName & ".lua 失败：" & vbCrLf & vbCrLf & _
               errMsg, _
               vbCritical, "严重错误"
        
        ReloadLuaFile = False
        Exit Function
    End If
    
    ReloadLuaFile = True
    Exit Function
    
ErrorHandler:
    If tempL <> 0 Then lua_close tempL
    MsgBox "重载过程发生 VBA 错误: " & Err.Description, vbCritical, "严重错误"
    ReloadLuaFile = False
End Function

' ====协程调度（私有）====
Private Sub ResumeTask(taskId As String)
    On Error GoTo ErrorHandler

    Dim task As Object
    Set task = m_TaskTable(taskId)

    If task("status") <> "yielded" Then Exit Sub

    Dim coThread As LongPtr
    coThread = task("coThread")

    lua_settop coThread, 0

    Dim nargs As Long
    nargs = 0

    ' 1. 优先使用 resumeSpec
    If task.Exists("resumeSpec") Then
        If IsArray(task("resumeSpec")) Then
            Dim i As Long
            For i = LBound(task("resumeSpec")) To UBound(task("resumeSpec"))
                Dim spec As Variant
                spec = task("resumeSpec")(i)

                If IsMissing(spec) Or IsEmpty(spec) Then GoTo NextSpec

                ' Range 对象
                If TypeName(spec) = "Range" Then
                    PushValue coThread, spec.Value
                    nargs = nargs + 1

                ' 字符串地址
                ElseIf VarType(spec) = vbString Then
                    On Error Resume Next
                    Dim rngVal As Variant
                    rngVal = m_Workbook.Application.Range(spec).Value
                    If Err.Number = 0 Then
                        PushValue coThread, rngVal
                        nargs = nargs + 1
                    End If
                    On Error GoTo ErrorHandler

                ' 其他值
                Else
                    PushValue coThread, spec
                    nargs = nargs + 1
                End If
NextSpec:
            Next
        End If
    End If

    ' 2. 修复：正确获取任务单元格的值
    If nargs = 0 Then
        Dim cellAddr As String
        cellAddr = task("cellAddr")
        
        On Error Resume Next
        Dim cellVal As Variant
        cellVal = m_Workbook.Application.Range(cellAddr).Value
        
        If Err.Number = 0 Then
            If Not IsEmpty(cellVal) And Not IsError(cellVal) Then
                PushValue coThread, cellVal
                nargs = 1
            End If
        End If
        On Error GoTo ErrorHandler
    End If

    ' 3. Resume 协程
    Dim nres As LongPtr
    Dim result As Long

    result = lua_resume(coThread, m_LuaState, nargs, VarPtr(nres))

    HandleResumeResult taskId, result, CLng(nres)
    Exit Sub

ErrorHandler:
    task("status") = "error"
    task("error") = "Resume 错误: " & Err.Description
End Sub
' 处理 yield/return 结果
Private Sub HandleResumeResult(taskId As String, result As Long, nres As Long)
    Dim task As Object
    Set task = m_TaskTable(taskId)
    
    Dim coThread As LongPtr
    coThread = task("coThread")
    
    Select Case result
        Case LUA_OK
            task("status") = "done"
            task("progress") = 100
            
            If nres > 0 Then
                Dim retData As Variant
                retData = GetValue(coThread, -1)
                ParseYieldReturn task, retData, True
            End If
            
        Case LUA_YIELD
            If nres > 0 Then
                Dim yieldData As Variant
                yieldData = GetValue(coThread, -1)
                ParseYieldReturn task, yieldData, False
            End If
            
            If task("status") <> "done" And task("status") <> "error" Then
                task("status") = "yielded"
            End If
            
        Case Else
            task("status") = "error"
            If nres > 0 Then
                task("error") = GetStringFromState(coThread, -1)
            Else
                task("error") = "协程错误: 代码 " & result
            End If
    End Select
    
    lua_settop coThread, 0
End Sub
' 解析 yield/return 字典
Private Sub ParseYieldReturn(task As Object, data As Variant, isFinal As Boolean)
    On Error Resume Next
    
    If Not IsArray(data) Then
        task("value") = data
        Exit Sub
    End If
    
    ' 检查是否为字典格式
    Dim isDictionary As Boolean
    isDictionary = False
    
    Dim cols As Long
    cols = UBound(data, 2) - LBound(data, 2) + 1
    If Err.Number = 0 And cols = 2 Then
        isDictionary = True
    End If
    On Error GoTo 0
    
    If isDictionary Then
        Dim i As Long
        For i = LBound(data, 1) To UBound(data, 1)
            Dim key As String
            Dim value As Variant
            
            key = LCase(Trim(CStr(data(i, 1))))
            value = data(i, 2)
            
            Select Case key
                Case "status"
                    If Not isFinal Then
                        Dim statusVal As String
                        statusVal = LCase(Trim(CStr(value)))
                        Select Case statusVal
                            Case "yielded", "done", "error"
                                task("status") = statusVal
                            Case Else
                                task("status") = "yielded"
                        End Select
                    End If
                Case "progress"
                    On Error Resume Next
                    task("progress") = CDbl(value)
                    On Error GoTo 0
                Case "message"
                    task("message") = value
                Case "value"
                    task("value") = value
            End Select
        Next
    Else
        task("value") = data
    End If
End Sub

' ==== Lua 栈操作工具（私有） ====
Private Sub PushValue(ByVal L As LongPtr, ByVal value As Variant)
    If TypeName(value) = "Range" Then
        Dim rng As Range
        Set rng = value
        If rng.Cells.Count = 1 Then
            PushValue L, rng.value
        Else
            PushValue L, rng.value
        End If
        Exit Sub
    End If
    
    If IsArray(value) Then
        PushArray L, value
        Exit Sub
    End If
    
    If IsEmpty(value) Or IsNull(value) Then
        lua_pushnil L
    ElseIf IsNumeric(value) Then
        lua_pushnumber L, CDbl(value)
    ElseIf VarType(value) = vbBoolean Then
        lua_pushboolean L, IIf(value, 1, 0)
    Else
        lua_pushstring L, CStr(value)
    End If
End Sub

Private Sub PushArray(ByVal L As LongPtr, arr As Variant)
    Dim i As Long, j As Long
    Dim rows As Long, cols As Long
    
    On Error Resume Next
    rows = UBound(arr, 1) - LBound(arr, 1) + 1
    cols = UBound(arr, 2) - LBound(arr, 2) + 1
    
    If Err.Number <> 0 Then
        Err.Clear
        On Error GoTo 0
        rows = UBound(arr) - LBound(arr) + 1
        
        lua_createtable L, rows, 0
        For i = LBound(arr) To UBound(arr)
            PushValue L, arr(i)
            lua_rawseti L, -2, i - LBound(arr) + 1
        Next
        Exit Sub
    End If
    On Error GoTo 0
    
    lua_createtable L, rows, 0
    For i = LBound(arr, 1) To UBound(arr, 1)
        lua_createtable L, cols, 0
        For j = LBound(arr, 2) To UBound(arr, 2)
            PushValue L, arr(i, j)
            lua_rawseti L, -2, j - LBound(arr, 2) + 1
        Next
        lua_rawseti L, -2, i - LBound(arr, 1) + 1
    Next
End Sub

Private Function GetValue(ByVal L As LongPtr, ByVal idx As Long) As Variant
    Dim luaType As Long
    luaType = lua_type(L, idx)
    
    Select Case luaType
        Case LUA_TNIL
            GetValue = Empty
        Case LUA_TBOOLEAN
            GetValue = (lua_toboolean(L, idx) <> 0)
        Case LUA_TNUMBER
            GetValue = lua_tonumberx(L, idx, 0)
        Case LUA_TSTRING
            GetValue = GetStringFromState(L, idx)
        Case LUA_TTABLE
            GetValue = TableToVariant(L, idx)
        Case Else
            GetValue = "#LUA_TYPE_" & luaType
    End Select
End Function

Private Function GetStringFromState(ByVal L As LongPtr, ByVal idx As Long) As String
    On Error GoTo ErrorHandler

    Dim ptr As LongPtr
    Dim length As Long
    
    ptr = lua_tolstring(L, idx, VarPtr(length))
    If ptr = 0 Or length = 0 Then
        GetStringFromState = ""
        Exit Function
    End If
    
    Dim bytes() As Byte
    ReDim bytes(0 To length - 1)
    CopyMemory bytes(0), ByVal ptr, length
    
    Dim stream As Object
    Set stream = CreateObject("ADODB.Stream")
    stream.Type = 1
    stream.Open
    stream.Write bytes
    stream.Position = 0
    stream.Type = 2
    stream.Charset = "UTF-8"
    GetStringFromState = stream.ReadText
    stream.Close
    Exit Function
ErrorHandler:
    GetStringFromState = ""
    If Not stream Is Nothing Then
        On Error Resume Next
        stream.Close
    End If
End Function

Private Function TableToVariant(ByVal L As LongPtr, ByVal idx As Long) As Variant
    On Error GoTo ErrorHandler
    
    If idx < 0 Then idx = lua_gettop(L) + idx + 1
    
    Dim length As LongPtr
    length = lua_rawlen(L, idx)
    
    ' length = 0 → 可能是字典
    If length = 0 Then
        lua_pushnil L
        If lua_next(L, idx) <> 0 Then
            lua_settop L, lua_gettop(L) - 2
            TableToVariant = TableToDictArray(L, idx)
        Else
            TableToVariant = Empty
        End If
        Exit Function
    End If
    
    ' 判断是否纯数组
    Dim isPureArray As Boolean
    isPureArray = True
    
    lua_pushnil L
    Do While lua_next(L, idx) <> 0
        If lua_type(L, -2) <> LUA_TNUMBER Then
            isPureArray = False
            lua_settop L, lua_gettop(L) - 2
            Exit Do
        End If
        lua_settop L, -2
    Loop
    
    If Not isPureArray Then
        TableToVariant = TableToDictArray(L, idx)
        Exit Function
    End If
    
    ' 纯数组：判断是否二维
    lua_rawgeti L, idx, 1
    Dim is2D As Boolean
    is2D = (lua_type(L, -1) = LUA_TTABLE)
    lua_settop L, -2
    
    Dim i As Long, j As Long
    
    If is2D Then
        lua_rawgeti L, idx, 1
        Dim cols As LongPtr
        cols = lua_rawlen(L, -1)
        lua_settop L, -2
        
        Dim arr2D() As Variant
        ReDim arr2D(1 To CLng(length), 1 To CLng(cols))
        
        For i = 1 To CLng(length)
            lua_rawgeti L, idx, i
            For j = 1 To CLng(cols)
                lua_rawgeti L, -1, j
                arr2D(i, j) = GetValue(L, -1)
                lua_settop L, -2
            Next
            lua_settop L, -2
        Next
        
        TableToVariant = arr2D
    Else
        Dim arr1D() As Variant
        ReDim arr1D(1 To 1, 1 To CLng(length))
        
        For i = 1 To CLng(length)
            lua_rawgeti L, idx, i
            arr1D(1, i) = GetValue(L, -1)
            lua_settop L, -2
        Next
        
        TableToVariant = arr1D
    End If
    
    Exit Function

ErrorHandler:
    TableToVariant = "#TABLE_ERROR: " & Err.Description
End Function

Private Function TableToDictArray(ByVal L As LongPtr, ByVal idx As Long) As Variant
    On Error GoTo ErrorHandler
    
    If idx < 0 Then idx = lua_gettop(L) + idx + 1
    
    Dim count As Long
    count = 0
    
    lua_pushnil L
    Do While lua_next(L, idx) <> 0
        count = count + 1
        lua_settop L, -2
    Loop
    
    If count = 0 Then
        TableToDictArray = Empty
        Exit Function
    End If
    
    Dim result() As Variant
    ReDim result(1 To count, 1 To 2)
    
    Dim i As Long
    i = 1
    
    lua_pushnil L
    Do While lua_next(L, idx) <> 0
        Select Case lua_type(L, -2)
            Case LUA_TSTRING
                result(i, 1) = GetStringFromState(L, -2)
            Case LUA_TNUMBER
                result(i, 1) = lua_tonumberx(L, -2, 0)
            Case LUA_TBOOLEAN
                result(i, 1) = (lua_toboolean(L, -2) <> 0)
            Case Else
                result(i, 1) = "#KEY_TYPE_" & lua_type(L, -2)
        End Select
        
        result(i, 2) = GetValue(L, -1)
        i = i + 1
        lua_settop L, -2
    Loop
    
    TableToDictArray = result
    Exit Function

ErrorHandler:
    TableToDictArray = "#DICT_ERROR: " & Err.Description
End Function

' ====给LuaMenu的接口====
' 设置热重载开关
Public Sub SetHotReloadEnabled(enabled As Boolean)
    m_HotReloadEnabled = enabled
End Sub
' 获取热重载状态
Public Function GetHotReloadEnabled() As Boolean
    GetHotReloadEnabled = m_HotReloadEnabled
End Function
' 清理已完成/错误的任务
Public Function CleanupFinishedTasks() As Long
    Dim count As Long
    count = 0
    
    Dim toRemove As Object
    Set toRemove = CreateObject("Scripting.Dictionary")
    
    Dim taskId As Variant
    Dim task As Object
    
    For Each taskId In m_TaskTable.Keys
        Set task = m_TaskTable(taskId)
        If task("status") = "done" Or task("status") = "error" Then
            toRemove(taskId) = True
            count = count + 1
        End If
    Next
    
    For Each taskId In toRemove.Keys
        TerminateTask CStr(taskId)
    Next
    
    CleanupFinishedTasks = count
End Function
' 清除所有任务
Public Sub ClearAllTasks()
    On Error GoTo ErrorHandler

    If m_TaskTable Is Nothing Or m_TaskTable.Count = 0 Then Exit Sub

    ' 先快照所有 taskId，避免遍历中修改 Dictionary
    Dim taskIds() As Variant
    taskIds = m_TaskTable.Keys

    Dim i As Long
    For i = LBound(taskIds) To UBound(taskIds)
        TerminateTask CStr(taskIds(i))
    Next i

    ' 兜底清理（理论上应已清空）
    If Not m_ActiveQueue Is Nothing Then
        m_ActiveQueue.RemoveAll
    End If

    ' 状态复位
    m_RoundRobinCursor = 0

    Exit Sub

ErrorHandler:
    Debug.Print "[ClearAllTasks] Error: " & Err.Description
End Sub

' 获取任务统计信息
Public Function GetTaskStats() As String
    Dim total As Long, defined As Long, yielded As Long
    Dim done As Long, errored As Long, paused As Long
    
    total = m_TaskTable.Count
    
    Dim taskId As Variant
    Dim task As Object
    
    For Each taskId In m_TaskTable.Keys
        Set task = m_TaskTable(taskId)
        Select Case task("status")
            Case "defined": defined = defined + 1
            Case "yielded": yielded = yielded + 1
            Case "done": done = done + 1
            Case "error": errored = errored + 1
            Case "paused": paused = paused + 1
        End Select
    Next
    
    GetTaskStats = "任务统计" & vbCrLf & _
                   "总数: " & total & vbCrLf & _
                   "已定义: " & defined & vbCrLf & _
                   "运行中: " & yielded & vbCrLf & _
                   "已暂停: " & paused & vbCrLf & _
                   "已完成: " & done & vbCrLf & _
                   "错误: " & errored
End Function
' 获取文件状态信息（用于调试）
Public Function GetFileStatus() As String
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    Dim msg As String
    msg = "Lua 文件状态" & vbCrLf & vbCrLf
    
    ' main.lua 状态
    msg = msg & "系统 main.lua:" & vbCrLf
    msg = msg & "  路径: " & m_SystemMainPath & vbCrLf
    If fso.FileExists(m_SystemMainPath) Then
        msg = msg & "  状态: 存在" & vbCrLf
        msg = msg & "  最后加载: " & m_LastMainModified & vbCrLf
        msg = msg & "  当前修改: " & FileDateTime(m_SystemMainPath) & vbCrLf
    Else
        msg = msg & "  状态: 不存在" & vbCrLf
    End If
    
    msg = msg & vbCrLf
    
    ' functions.lua 状态
    msg = msg & "工作簿 functions.lua:" & vbCrLf
    msg = msg & "  路径: " & m_FunctionsPath & vbCrLf
    If fso.FileExists(m_FunctionsPath) Then
        msg = msg & "  状态: 存在" & vbCrLf
        msg = msg & "  最后加载: " & m_LastFunctionsModified & vbCrLf
        msg = msg & "  当前修改: " & FileDateTime(m_FunctionsPath) & vbCrLf
    Else
        msg = msg & "  状态: 不存在" & vbCrLf
    End If
    
    msg = msg & vbCrLf
    msg = msg & "热更新: " & IIf(m_HotReloadEnabled, "已启用", "已禁用")
    
    GetFileStatus = msg
End Function

Public Function GetAllTasksInfo() As String
    Dim msg As String
    Dim taskId As Variant
    Dim task As Object
    
    Dim total As Long
    Dim defined As Long, yielded As Long
    Dim done As Long, errored As Long, paused As Long
    
    total = m_TaskTable.Count
    
    msg = "========================================" & vbCrLf
    msg = msg & "  Lua 协程任务列表" & vbCrLf
    msg = msg & "========================================" & vbCrLf & vbCrLf
    
    msg = msg & "任务总数: " & total & vbCrLf & vbCrLf
    
    ' ===== 统计状态 =====
    For Each taskId In m_TaskTable.Keys
        Set task = m_TaskTable(taskId)
        Select Case task("status")
            Case "defined": defined = defined + 1
            Case "yielded": yielded = yielded + 1
            Case "done": done = done + 1
            Case "error": errored = errored + 1
            Case "paused": paused = paused + 1
        End Select
    Next
    
    msg = msg & "状态统计:" & vbCrLf
    msg = msg & "  defined : " & defined & vbCrLf
    msg = msg & "  yielded : " & yielded & vbCrLf
    msg = msg & "  paused  : " & paused & vbCrLf
    msg = msg & "  done    : " & done & vbCrLf
    msg = msg & "  error   : " & errored & vbCrLf
    msg = msg & vbCrLf & "----------------------------------------" & vbCrLf & vbCrLf
    
    ' ===== 逐任务详情 =====
    Dim index As Long
    index = 1
    
    For Each taskId In m_TaskTable.Keys
        Set task = m_TaskTable(taskId)
        
        msg = msg & "【任务 #" & index & "】" & vbCrLf
        msg = msg & "ID      : " & taskId & vbCrLf
        msg = msg & "函数    : " & task("funcName") & vbCrLf
        msg = msg & "单元格  : " & task("cellAddr") & vbCrLf
        msg = msg & "状态    : " & task("status") & vbCrLf
        msg = msg & "进度    : " & Format(task("progress"), "0.0") & "%" & vbCrLf
        
        If Not IsEmpty(task("message")) Then
            msg = msg & "消息    : " & CStr(task("message")) & vbCrLf
        End If
        
        If task("status") = "error" And task("error") <> "" Then
            msg = msg & "错误    : " & task("error") & vbCrLf
        End If
        
        msg = msg & "活跃队列: " & IIf(m_ActiveQueue.Exists(taskId), "是", "否") & vbCrLf
        
        msg = msg & "----------------------------------------" & vbCrLf
        index = index + 1
    Next
    
    GetAllTasksInfo = msg
End Function

Public Function GetTaskDetail(taskId As String) As Object
    If Not m_TaskTable.Exists(taskId) Then
        Set GetTaskDetail = Nothing
        Exit Function
    End If

    Dim src As Object
    Set src = m_TaskTable(taskId)

    ' 返回一个只读副本（防止 LuaMenu 篡改内部状态）
    Dim info As Object
    Set info = CreateObject("Scripting.Dictionary")

    info("taskId") = taskId
    info("funcName") = src("funcName")
    info("cellAddr") = src("cellAddr")
    info("status") = src("status")
    info("progress") = src("progress")
    info("message") = src("message")
    info("value") = src("value")
    info("error") = src("error")
    info("coThread") = src("coThread")
    info("startArgs") = src("startArgs")
    info("resumeSpec") = src("resumeSpec")

    Set GetTaskDetail = info
End Function
    
Public Property Get GetWorkbook() As Workbook
    Set GetWorkbook = m_Workbook
End Property' ============================================
' Scheduler.bas - 进程级调度器
' ============================================
' 设计原因：
' 1. 进程级唯一，不依赖具体 Workbook
' 2. 只通过 WorkbookRuntime 接口驱动，不知道 Task/Lua
' 3. 使用 OnTime 实现异步调度
' ============================================

Option Explicit

' 全局状态（仅调度器可见）
Private g_Runnables As Collection      ' WorkbookRuntime 集合
Private g_SchedulerRunning As Boolean
Private g_NextTaskId As Long
Private g_SchedulerIntervalMs As Integer
Private g_SchedulerIntervalInited As Boolean
' 配置常量
Private Const DEFAULT_INTERVAL_Ms As Integer = 1000  ' 1000 毫秒

' ====公共接口====
' 初始化调度器
Public Sub InitScheduler()
    ' 修复：确保 g_Runnables 被初始化
    If g_Runnables Is Nothing Then
        Set g_Runnables = New Collection
    End If
    
    If Not g_SchedulerIntervalInited Then
        g_SchedulerIntervalMs = DEFAULT_INTERVAL_Ms
        g_SchedulerIntervalInited = True
        g_NextTaskId = 0
    End If
End Sub
' 注册运行时（由 CoreRegistry 调用）
Public Sub RegisterRunnable(rt As WorkbookRuntime)
    If g_Runnables Is Nothing Then InitScheduler
    On Error Resume Next
    g_Runnables.Add rt
End Sub
' 注销运行时
Public Sub UnregisterRunnable(rt As WorkbookRuntime)
    On Error Resume Next
    Dim i As Long
    For i = g_Runnables.Count To 1 Step -1
        If g_Runnables(i) Is rt Then
            g_Runnables.Remove i
            Exit For
        End If
    Next
End Sub
' 启动调度器
Public Sub StartScheduler()
    If g_Runnables Is Nothing Then InitScheduler
    If g_SchedulerRunning Then
        MsgBox "调度器已启动", vbInformation
        Exit Sub
    End If
    g_SchedulerRunning = True
    SchedulerTick
End Sub
' 停止调度器
Public Sub StopScheduler()
    g_SchedulerRunning = False
    On Error Resume Next
    Application.OnTime EarliestTime:=Now + TimeValue("00:00:01"), _
                       Procedure:="Scheduler.SchedulerTick", _
                       Schedule:=False
End Sub
' 设置调度间隔
Public Sub SetSchedulerInterval(intervalMs As Double)
    If intervalMs < 10 Or intervalMs > 3600000 Then
        Err.Raise vbObjectError + 1, , "间隔必须在 10-3600000 毫秒之间"
    End If
    g_SchedulerIntervalMs = intervalMs
End Sub
' 生成唯一 TaskId（工具函数，供 WorkbookRuntime 使用）
Public Function GenerateTaskId(wbKey As String, cellAddr As String) As String
    GenerateTaskId = "TASK_" & g_NextTaskId & "_" & wbKey & "_" & cellAddr
    g_NextTaskId = g_NextTaskId + 1
End Function

Property Get IsRunning() As Boolean
  IsRunning = g_SchedulerRunning
End Property

' ====内部实现====
' 调度心跳（OnTime 回调）
Public Sub SchedulerTick()
    On Error Resume Next
    
    If Not g_SchedulerRunning Then Exit Sub
    If g_Runnables Is Nothing Then Exit Sub
    
    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual

    Dim rt As WorkbookRuntime
    Dim hasWork As Boolean
    hasWork = False
    
    ' 优化：只标记有工作的 runtime
    Dim needsCalc As Boolean
    needsCalc = False
    
    For Each rt In g_Runnables
        If rt.HasRunnable Then
            rt.Tick
            hasWork = True
            needsCalc = True
        End If
    Next rt
    
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    Application.ScreenUpdating = True
    
    ' 只在有实际工作时才刷新
    If needsCalc Then
        On Error Resume Next
        ActiveSheet.Calculate
    End If
    
    ' 继续调度或停止
    If hasWork Or g_Runnables.Count > 0 Then
        Dim nextTime As Date
        nextTime = Now + TimeValue("00:00:01") * g_SchedulerIntervalMs / 1000
        Application.OnTime EarliestTime:=nextTime, _
                           Procedure:="Scheduler.SchedulerTick", _
                           Schedule:=True
    Else
        g_SchedulerRunning = False
    End If
End Sub' ============================================
' CoreRegistry.bas - 运行时注册表（完整版）
' ============================================
' 设计原因：
' 1. 封装所有 Dictionary 访问
' 2. 提供 taskId → Runtime 路由
' 3. 管理 Workbook → Runtime 映射
' 4. 新增 cellAddr → taskId 索引
' 5. 提供 WorkbookKey 工具
' ============================================

Option Explicit

' ===== 全局注册表（仅本模块访问）=====
Private g_RuntimeByWorkbook As Object  ' wbKey → WorkbookRuntime
Private g_RuntimeByTaskIndex As Object ' taskId → WorkbookRuntime
Private g_TaskIdByCellAddr As Object   ' cellAddr → taskId

' ====初始化====
Private Sub InitRegistry()
    If g_RuntimeByWorkbook Is Nothing Then
        Set g_RuntimeByWorkbook = CreateObject("Scripting.Dictionary")
        Set g_RuntimeByTaskIndex = CreateObject("Scripting.Dictionary")
        Set g_TaskIdByCellAddr = CreateObject("Scripting.Dictionary")
    End If
End Sub

' ====运行时管理====
' 注册工作簿运行时
Public Sub RegisterWorkbookRuntime(wb As Workbook, rt As WorkbookRuntime)
    InitRegistry
    Dim wbKey As String
    wbKey = GetWorkbookKey(wb)
    g_RuntimeByWorkbook(wbKey) = rt
    
    ' 注册到调度器
    Scheduler.RegisterRunnable rt
End Sub

' 注销工作簿运行时
Public Sub UnregisterWorkbookRuntime(wb As Workbook)
    InitRegistry
    Dim wbKey As String
    wbKey = GetWorkbookKey(wb)

    If g_RuntimeByWorkbook.Exists(wbKey) Then
        Dim rt As WorkbookRuntime
        Set rt = g_RuntimeByWorkbook(wbKey)
        ' 从调度器注销
        Scheduler.UnregisterRunnable rt
        ' 清理资源
        rt.Dispose
        ' 从注册表移除
        g_RuntimeByWorkbook.Remove wbKey
    End If
End Sub

' 根据 Workbook 获取运行时
Public Function GetRuntimeByWorkbook(wb As Workbook) As WorkbookRuntime
    InitRegistry
    Dim wbKey As String
    wbKey = GetWorkbookKey(wb)
    
    If g_RuntimeByWorkbook.Exists(wbKey) Then
        Set GetRuntimeByWorkbook = g_RuntimeByWorkbook(wbKey)
    Else
        Set GetRuntimeByWorkbook = Nothing
    End If
End Function

' ====Task 路由表（GlobalTaskIndex）====
' 注册任务到运行时的映射
Public Sub RegisterTask(taskId As String, rt As WorkbookRuntime, cellAddr As String)
    InitRegistry
    g_RuntimeByTaskIndex(taskId) = rt
    
    ' 新增：注册 cellAddr → taskId 映射
    If cellAddr <> "" Then
        g_TaskIdByCellAddr(cellAddr) = taskId
    End If
End Sub

' 根据 taskId 解析运行时
Public Function ResolveRuntime(taskId As String) As WorkbookRuntime
    InitRegistry
    If g_RuntimeByTaskIndex.Exists(taskId) Then
        Set ResolveRuntime = g_RuntimeByTaskIndex(taskId)
    Else
        Set ResolveRuntime = Nothing
    End If
End Function

' 注销任务
Public Sub UnregisterTask(taskId As String, cellAddr As String)
    InitRegistry
    
    If g_RuntimeByTaskIndex.Exists(taskId) Then
        g_RuntimeByTaskIndex.Remove taskId
    End If
    
    ' 新增：清理 cellAddr 索引
    If cellAddr <> "" And g_TaskIdByCellAddr.Exists(cellAddr) Then
        g_TaskIdByCellAddr.Remove cellAddr
    End If
End Sub

' ============================================
' 单元格地址索引（新增）
' ============================================

' 根据单元格地址查找任务 ID
Public Function FindTaskByCell(cellAddr As String) As String
    InitRegistry
    
    If g_TaskIdByCellAddr.Exists(cellAddr) Then
        FindTaskByCell = g_TaskIdByCellAddr(cellAddr)
    Else
        FindTaskByCell = ""
    End If
End Function

' 检查单元格是否已有任务
Public Function CellHasTask(cellAddr As String) As Boolean
    InitRegistry
    CellHasTask = g_TaskIdByCellAddr.Exists(cellAddr)
End Function

' ============================================
' 工具函数（WorkbookKey 生成）
' ============================================

' 生成唯一的 Workbook 标识
' 设计原因：FullName 可能重复（不同路径同名文件）
' 使用 Name + CreationDate 组合
Public Function GetWorkbookKey(wb As Workbook) As String
    On Error Resume Next
    GetWorkbookKey = wb.Name & "_" & Format(wb.BuiltinDocumentProperties("Creation Date"), "yyyymmddhhnnss")
    If Err.Number <> 0 Then
        ' 回退方案：使用 Name + 当前时间
        GetWorkbookKey = wb.Name & "_" & Format(Now, "yyyymmddhhnnss")
    End If
End Function

' 从外部地址提取 WorkbookKey
' 例如：'[Book1.xlsx]Sheet1'!$A$1 → Book1.xlsx
Public Function ExtractWorkbookFromAddress(addr As String) As String
    Dim startPos As Long, endPos As Long
    startPos = InStr(addr, "[")
    endPos = InStr(addr, "]")
    
    If startPos > 0 And endPos > startPos Then
        ExtractWorkbookFromAddress = Mid(addr, startPos + 1, endPos - startPos - 1)
    Else
        ExtractWorkbookFromAddress = ""
    End If
End Function' ============================================
' LuaMenu.bas - 用户界面模块
' ============================================
' 设计原因：
' 1. 统一管理菜单创建/销毁
' 2. OnAction 路由到对应 WorkbookRuntime
' 3. 提供日志/消息框工具
' 4. 不访问 TaskTable，不修改 Task 状态
' ============================================

Option Explicit

' ===== 日志工具 =====
Public Sub LogInfo(msg As String)
    Debug.Print "[INFO] " & msg
End Sub
Public Sub LogError(msg As String)
    Debug.Print "[ERROR] " & msg
    MsgBox msg, vbCritical, "错误"
End Sub

' ====菜单管理====
' 创建右键菜单
Public Sub EnableLuaTaskMenu()
    On Error Resume Next
    DisableLuaTaskMenu

    Dim cellMenu As CommandBar
    Set cellMenu = Application.CommandBars("Cell")
    
    ' 任务管理菜单
    Dim luaTaskMenu As CommandBarControl
    Set luaTaskMenu = cellMenu.Controls.Add(Type:=msoControlPopup, Temporary:=True)
    luaTaskMenu.Caption = "Lua 任务管理"
    luaTaskMenu.Tag = "LuaTaskMenu"
    AddLuaMenuItem luaTaskMenu, "启动任务", "LuaTaskMenu_StartTask"
    AddLuaMenuItem luaTaskMenu, "暂停任务", "LuaTaskMenu_PauseTask"
    AddLuaMenuItem luaTaskMenu, "恢复任务", "LuaTaskMenu_ResumeTask"
    AddLuaMenuItem luaTaskMenu, "终止任务", "LuaTaskMenu_TerminateTask"
    AddLuaMenuItem luaTaskMenu, "查看任务详情", "LuaTaskMenu_ShowTaskDetail"

    ' 调度管理菜单
    Dim luaSchedulerMenu As CommandBarControl
    Set luaSchedulerMenu = cellMenu.Controls.Add(Type:=msoControlPopup, Temporary:=True)
    luaSchedulerMenu.Caption = "Lua 调度管理"
    luaSchedulerMenu.Tag = "LuaSchedulerMenu"
    AddLuaMenuItem luaSchedulerMenu, "启动所有 defined 任务", "LuaSchedulerMenu_StartAllDefinedTasks"
    AddLuaMenuItem luaSchedulerMenu, "清理所有完成、错误任务", "LuaSchedulerMenu_CleanupFinishedTasks"
    AddLuaMenuItem luaSchedulerMenu, "删除所有任务", "LuaSchedulerMenu_ClearAllTasks"
    AddLuaMenuItem luaSchedulerMenu, "显示所有任务信息", "LuaSchedulerMenu_ShowAllTasks"
    AddLuaMenuItem luaSchedulerMenu, "启动调度器", "LuaSchedulerMenu_StartScheduler"
    AddLuaMenuItem luaSchedulerMenu, "停止调度器", "LuaSchedulerMenu_StopScheduler"

    ' 设置管理菜单
    Dim luaConfigMenu As CommandBarControl
    Set luaConfigMenu = cellMenu.Controls.Add(Type:=msoControlPopup, Temporary:=True)
    luaConfigMenu.Caption = "Lua 设置管理"
    luaConfigMenu.Tag = "luaConfigMenu"
    AddLuaMenuItem luaConfigMenu, "启用热重载", "LuaConfigMenu_EnableHotReload"
    AddLuaMenuItem luaConfigMenu, "禁用热重载", "LuaConfigMenu_DisableHotReload"
    AddLuaMenuItem luaConfigMenu, "手动重载 functions.lua", "LuaConfigMenu_ReloadFunctions"
    AddLuaMenuItem luaConfigMenu, "设置调度间隔（秒）", "LuaConfigMenu_SetSchedulerInterval"

    MsgBox "Lua 任务右键菜单已启用。", vbInformation
End Sub

Public Sub DisableLuaTaskMenu()
    On Error Resume Next
    
    Dim cellMenu As CommandBar
    Set cellMenu = Application.CommandBars("Cell")
    
    Dim ctrl As CommandBarControl
    For Each ctrl In cellMenu.Controls
        If ctrl.Tag = "LuaTaskMenu" Then ctrl.Delete
        If ctrl.Tag = "LuaSchedulerMenu" Then ctrl.Delete
        If ctrl.Tag = "LuaConfigMenu" Then ctrl.Delete
    Next
End Sub

Private Sub AddLuaMenuItem(parent As CommandBarControl, caption As String, onAction As String)
    Dim ctrl As CommandBarControl
    Set ctrl = parent.Controls.Add(Type:=msoControlButton, Temporary:=True)
    ctrl.Caption = caption
    ctrl.OnAction = onAction
End Sub

Private Function GetRuntimeFromSelection() As WorkbookRuntime
    Dim wb As Workbook
    Set wb = ActiveWorkbook
    If wb Is Nothing Then
        Set GetRuntimeFromSelection = Nothing
        Exit Function
    End If
    
    Set GetRuntimeFromSelection = CoreRegistry.GetRuntimeByWorkbook(wb)
End Function

Private Function GetTaskIdFromSelection() As String
    On Error Resume Next
    Dim taskId As String
    taskId = CStr(Selection.Value)
    
    If Left(taskId, 5) = "TASK_" Then
        GetTaskIdFromSelection = taskId
    Else
        GetTaskIdFromSelection = ""
    End If
End Function

' ============================================
' 任务管理回调函数
' ============================================

Public Sub LuaTaskMenu_StartTask()
    Dim rt As WorkbookRuntime
    Set rt = GetRuntimeFromSelection()
    If rt Is Nothing Then
        MsgBox "未找到工作簿运行时", vbExclamation
        Exit Sub
    End If
    
    Dim taskId As String
    taskId = GetTaskIdFromSelection()
    If taskId = "" Then
        MsgBox "当前单元格没有任务", vbExclamation
        Exit Sub
    End If
    
    On Error GoTo ErrorHandler
    rt.StartTask taskId
    MsgBox "任务已启动: " & taskId, vbInformation
    Exit Sub
ErrorHandler:
    LogError "启动任务失败: " & Err.Description
End Sub

Public Sub LuaTaskMenu_PauseTask()
    Dim rt As WorkbookRuntime
    Set rt = GetRuntimeFromSelection()
    If rt Is Nothing Then Exit Sub
    
    Dim taskId As String
    taskId = GetTaskIdFromSelection()
    If taskId = "" Then Exit Sub
    
    rt.PauseTask taskId
    MsgBox "任务已暂停", vbInformation
End Sub

Public Sub LuaTaskMenu_ResumeTask()
    Dim rt As WorkbookRuntime
    Set rt = GetRuntimeFromSelection()
    If rt Is Nothing Then Exit Sub
    
    Dim taskId As String
    taskId = GetTaskIdFromSelection()
    If taskId = "" Then Exit Sub
    
    rt.ResumeTaskManual taskId
    MsgBox "任务已恢复", vbInformation
End Sub

Public Sub LuaTaskMenu_TerminateTask()
    Dim rt As WorkbookRuntime
    Set rt = GetRuntimeFromSelection()
    If rt Is Nothing Then Exit Sub
    
    Dim taskId As String
    taskId = GetTaskIdFromSelection()
    If taskId = "" Then Exit Sub
    
    Dim result As VbMsgBoxResult
    result = MsgBox("确定终止任务？", vbYesNo + vbExclamation)
    If result = vbYes Then
        rt.TerminateTask taskId
        MsgBox "任务已终止", vbInformation
    End If
End Sub

Public Sub LuaTaskMenu_ShowTaskDetail()
    Dim rt As WorkbookRuntime
    Set rt = GetRuntimeFromSelection()
    If rt Is Nothing Then
        MsgBox "未找到工作簿运行时", vbExclamation
        Exit Sub
    End If

    Dim taskId As String
    taskId = GetTaskIdFromSelection()
    If taskId = "" Then
        MsgBox "当前单元格没有 Lua 任务。", vbExclamation
        Exit Sub
    End If

    Dim info As Object
    Set info = rt.GetTaskDetail(taskId)
    If info Is Nothing Then
        MsgBox "任务不存在或已被清理。", vbExclamation
        Exit Sub
    End If

    Dim msg As String
    msg = "========================================" & vbCrLf
    msg = msg & "  Lua 任务详情" & vbCrLf
    msg = msg & "========================================" & vbCrLf & vbCrLf

    msg = msg & "任务 ID: " & info("taskId") & vbCrLf
    msg = msg & "函数名: " & info("funcName") & vbCrLf
    msg = msg & "单元格: " & info("cellAddr") & vbCrLf
    msg = msg & "状态: " & info("status") & vbCrLf
    msg = msg & "进度: " & Format(info("progress"), "0.00") & "%" & vbCrLf

    If Not IsEmpty(info("message")) Then
        msg = msg & "消息: " & CStr(info("message")) & vbCrLf
    End If

    msg = msg & vbCrLf & "----------------------------------------" & vbCrLf

    ' 返回值
    If IsArray(info("value")) Then
        msg = msg & "返回值: (数组)" & vbCrLf
    ElseIf IsEmpty(info("value")) Then
        msg = msg & "返回值: (空)" & vbCrLf
    Else
        msg = msg & "返回值: " & CStr(info("value")) & vbCrLf
    End If

    ' 错误信息
    If info("status") = "error" Then
        msg = msg & vbCrLf & "错误信息:" & vbCrLf
        msg = msg & CStr(info("error")) & vbCrLf
    End If

    ' 协程
    msg = msg & vbCrLf & "----------------------------------------" & vbCrLf
    msg = msg & "协程线程: "
    If info("coThread") = 0 Then
        msg = msg & "未创建" & vbCrLf
    Else
        msg = msg & "0x" & Hex(info("coThread")) & vbCrLf
    End If

    MsgBox msg, vbInformation, "Lua 任务详情"
End Sub

' ============================================
' 调度管理回调函数
' ============================================

Public Sub LuaSchedulerMenu_StartAllDefinedTasks()
    Dim rt As WorkbookRuntime
    Set rt = GetRuntimeFromSelection()
    If rt Is Nothing Then
        MsgBox "未找到工作簿运行时", vbExclamation
        Exit Sub
    End If
    
    ' 注意：这需要在 WorkbookRuntime 中添加 GetAllTasks 方法
    ' 当前简化实现：提示用户手动启动
    MsgBox "请在需要启动的任务单元格上右键选择 '启动任务'" & vbCrLf & _
           "批量启动功能需要额外实现 WorkbookRuntime.GetAllTasks()", _
           vbInformation
End Sub

Public Sub LuaSchedulerMenu_CleanupFinishedTasks()
    Dim rt As WorkbookRuntime
    Set rt = GetRuntimeFromSelection()
    If rt Is Nothing Then
        MsgBox "未找到工作簿运行时", vbExclamation
        Exit Sub
    End If
    rt.CleanUpFinishedTasks
End Sub

Public Sub LuaSchedulerMenu_ClearAllTasks()
    Dim rt As WorkbookRuntime
    Set rt = GetRuntimeFromSelection()
    If rt Is Nothing Then
        MsgBox "未找到工作簿运行时", vbExclamation
        Exit Sub
    End If
    
    Dim result As VbMsgBoxResult
    result = MsgBox("确定删除所有任务？此操作不可撤销！", vbYesNo + vbExclamation)
    If result <> vbYes Then Exit Sub
    
    rt.ClearAllTasks
    MsgBox "所有任务已删除", vbInformation
End Sub

Public Sub LuaSchedulerMenu_ShowAllTasks()
    Dim rt As WorkbookRuntime
    Set rt = GetRuntimeFromSelection()
    If rt Is Nothing Then
        MsgBox "未找到工作簿运行时", vbExclamation
        Exit Sub
    End If
    
    MsgBox rt.GetAllTasksInfo(), vbInformation, "Lua 任务列表"
End Sub

Public Sub LuaSchedulerMenu_StartScheduler()
    Scheduler.StartScheduler
    MsgBox "调度器已启动", vbInformation
End Sub

Public Sub LuaSchedulerMenu_StopScheduler()
    Scheduler.StopScheduler
    MsgBox "调度器已停止", vbInformation
End Sub

' ============================================
' 设置管理回调函数
' ============================================

Public Sub LuaConfigMenu_EnableHotReload()
    Dim rt As WorkbookRuntime
    Set rt = GetRuntimeFromSelection()
    If rt Is Nothing Then
        MsgBox "未找到工作簿运行时", vbExclamation
        Exit Sub
    End If
    
    ' 注意：需要在 WorkbookRuntime 中添加 SetHotReloadEnabled 方法
    ' 或者直接访问 m_HotReloadEnabled（需要改为 Public Property）
    MsgBox "热重载功能需要在 WorkbookRuntime 中添加 SetHotReloadEnabled() 方法" & vbCrLf & _
           "当前热重载默认启用", _
           vbInformation
End Sub

Public Sub LuaConfigMenu_DisableHotReload()
    Dim rt As WorkbookRuntime
    Set rt = GetRuntimeFromSelection()
    If rt Is Nothing Then
        MsgBox "未找到工作簿运行时", vbExclamation
        Exit Sub
    End If
    
    MsgBox "热重载功能需要在 WorkbookRuntime 中添加 SetHotReloadEnabled() 方法" & vbCrLf & _
           "临时解决方案：手动修改 WorkbookRuntime 的 DEFAULT_HOT_RELOAD_ENABLED 常量", _
           vbInformation
End Sub

Public Sub LuaConfigMenu_ReloadFunctions()
    Dim rt As WorkbookRuntime
    Set rt = GetRuntimeFromSelection()
    If rt Is Nothing Then
        MsgBox "未找到工作簿运行时", vbExclamation
        Exit Sub
    End If
    
    If rt.ReloadFunctions() Then
        MsgBox "functions.lua 已重载", vbInformation
    Else
        MsgBox "重载失败，请检查 functions.lua 是否存在语法错误", vbCritical
    End If
End Sub

Public Sub LuaConfigMenu_SetSchedulerInterval()
    Dim i As String
    i = InputBox("请输入调度间隔（秒）：", "设置调度间隔", "1")
    
    If i = "" Then Exit Sub
    
    On Error GoTo ErrorHandler
    Dim intervalSec As Double
    intervalSec = CDbl(i)
    If intervalSec < 0.01 Or intervalSec > 3600 Then
        MsgBox "间隔必须在 0.01-3600 秒之间", vbExclamation
        Exit Sub
    End If
    
    Scheduler.SetSchedulerInterval intervalSec * 1000
    MsgBox "调度间隔已设置为 " & intervalSec & " 秒", vbInformation
    Exit Sub
    
ErrorHandler:
    MsgBox "输入无效：" & Err.Description, vbCritical
End Sub' ============================================
' UDF.bas - 用户自定义函数
' ============================================
' 设计原因：
' 1. 提供 Excel 公式接口
' 2. 通过 CoreRegistry 路由到对应 WorkbookRuntime
' 3. 不直接访问 TaskTable
' 4. LuaEval 和 LuaCall 用于同步 Lua 调用
' ============================================

Option Explicit

' ====LuaTask - 定义协程任务====
' 用法：=LuaTask("funcName", arg1, arg2, "|", resumeArg1, resumeArg2)
' 返回：taskId（字符串）
Public Function LuaTask(ParamArray params() As Variant) As String
    On Error GoTo ErrorHandler
    
    ' 获取调用单元格所在的 Workbook
    Dim wb As Workbook
    Set wb = Application.Caller.Parent.Parent
    
    ' 获取对应的 WorkbookRuntime
    Dim rt As WorkbookRuntime
    Set rt = CoreRegistry.GetRuntimeByWorkbook(wb)
    
    If rt Is Nothing Then
        LuaTask = "#ERROR: 未找到运行时"
        Exit Function
    End If
    
    ' 解析参数
    If UBound(params) < 0 Then
        LuaTask = "#ERROR: 需要函数名"
        Exit Function
    End If
    
    Dim funcName As String
    funcName = CStr(params(0))
    
    Dim cellAddr As String
    cellAddr = Application.Caller.Address(External:=True)
    
    ' 检查是否已有任务（通过 CoreRegistry）
    Dim existingTaskId As String
    existingTaskId = CoreRegistry.FindTaskByCell(cellAddr)
    If existingTaskId <> "" Then
        LuaTask = existingTaskId
        Exit Function
    End If
    
    ' 分离 startArgs 和 resumeSpec
    Dim startList As Object, resumeList As Object
    Set startList = CreateObject("System.Collections.ArrayList")
    Set resumeList = CreateObject("System.Collections.ArrayList")
    
    Dim phase As Long
    phase = 0  ' 0=start, 1=resume
    
    Dim i As Long
    For i = 1 To UBound(params)
        If VarType(params(i)) = vbString And params(i) = "|" Then
            phase = 1
        Else
            If phase = 0 Then
                startList.Add params(i)
            Else
                resumeList.Add params(i)
            End If
        End If
    Next
    
    Dim startArgs As Variant, resumeSpec As Variant
    If startList.Count > 0 Then
        startArgs = startList.ToArray()
    Else
        startArgs = Array()
    End If
    
    If resumeList.Count > 0 Then
        resumeSpec = resumeList.ToArray()
    Else
        resumeSpec = Array()
    End If
    
    ' 创建任务
    Dim taskId As String
    taskId = rt.CreateTask(cellAddr, funcName, startArgs, resumeSpec)
    
    LuaTask = taskId
    Exit Function
    
ErrorHandler:
    LuaTask = "#ERROR: " & Err.Description
End Function
' ====LuaGet - 获取任务字段====
Public Function LuaGet(taskId As String, field As String) As Variant
    On Error GoTo ErrorHandler
    
    Application.Volatile True
    
    ' 通过全局路由表解析运行时
    Dim rt As WorkbookRuntime
    Set rt = CoreRegistry.ResolveRuntime(taskId)
    
    If rt Is Nothing Then
        LuaGet = "#ERROR: 任务不存在"
        Exit Function
    End If
    
    LuaGet = rt.GetTaskField(taskId, field)
    Exit Function
    
ErrorHandler:
    LuaGet = "#ERROR: " & Err.Description
End Function

' ====LuaEval - 执行 Lua 表达式（同步）====
' 用法: =LuaEval("1 + 1")
'      =LuaCall("funcName", arg1, arg2)
Public Function LuaEval(expression As String) As Variant
    On Error GoTo ErrorHandler
    
    Application.Volatile True
    
    ' 获取调用单元格所在的 Workbook
    Dim wb As Workbook
    Set wb = Application.Caller.Parent.Parent
    
    ' 获取对应的 WorkbookRuntime
    Dim rt As WorkbookRuntime
    Set rt = CoreRegistry.GetRuntimeByWorkbook(wb)
    
    If rt Is Nothing Then
        LuaEval = "#ERROR: 未找到运行时"
        Exit Function
    End If
    
    ' 调用 Runtime 的 Eval 方法
    LuaEval = rt.EvalExpression(expression)
    Exit Function
    
ErrorHandler:
    LuaEval = "#ERROR: " & Err.Description
End Function
Public Function LuaCall(funcName As String, ParamArray args() As Variant) As Variant
    On Error GoTo ErrorHandler
    
    Application.Volatile True
    
    ' 获取调用单元格所在的 Workbook
    Dim wb As Workbook
    Set wb = Application.Caller.Parent.Parent
    
    ' 获取对应的 WorkbookRuntime
    Dim rt As WorkbookRuntime
    Set rt = CoreRegistry.GetRuntimeByWorkbook(wb)
    
    If rt Is Nothing Then
        LuaCall = "#ERROR: 未找到运行时"
        Exit Function
    End If
    
    ' 将 ParamArray 转换为普通数组
    Dim argArray() As Variant
    If UBound(args) >= LBound(args) Then
        ReDim argArray(LBound(args) To UBound(args))
        Dim i As Long
        For i = LBound(args) To UBound(args)
            argArray(i) = args(i)
        Next
    Else
        argArray = Array()
    End If
    
    ' 调用 Runtime 的 CallFunction 方法
    LuaCall = rt.CallFunction(funcName, argArray)
    Exit Function
    
ErrorHandler:
    LuaCall = "#ERROR: " & Err.Description
End Function