进程全局实例：右键菜单（菜单回调函数只做一件事：定位当前 ActiveWorkbook，转发到该工作簿的“控制器对象”）、OnTime调度器、状态缓存、任务表(全局就不用轮询每个工作簿了)。

调度器：现在是：全局调度器 → 轮询全局任务表，可以进一步抽象为：Scheduler 只调度“可运行单元”，不关心任务来自哪个工作簿。
建议引入一个概念层级：
Scheduler
 └─ Runnable (接口)
     ├─ WorkbookRuntime#1
     │   └─ Lua Tasks
     ├─ WorkbookRuntime#2
     │   └─ Lua Tasks
调度器只做：Round-robin 调 Runnable.Tick()，每个工作簿自己决定 tick 内跑几个 Lua 协程。这样可以：控制单工作簿“独占 CPU”，防止某个工作簿任务爆炸拖垮全局

任务表不应该直接存 Lua 任务。建议的拆分层级：
进程级：
GlobalTaskIndex
taskId → 所属 WorkbookRuntime
用于菜单 / UDF / Scheduler 查路由
工作簿级：
WorkbookRuntime.TaskTable
真正的 Lua 协程、参数、状态
完全私有
这样可以避免：工作簿关闭时误删他人任务，TaskId 冲突，全局字典无限膨胀

每个工作簿独立实例：functions.lua代码及热更新（可能牵扯到lua脚本不停地更换，反复编译性能浪费）、lua VM、参数压栈、出栈 。代码还要实现一次修改，处处运行。

每个工作簿一个 Lua VM，但：热更新做到“模块级”，不是“整 VM 重载”，热更新时：只卸载被修改的模块不销毁 VM，已运行协程继续用旧闭包，新任务用新版本
“一次修改，处处运行”的正确实现方式，这句话不是指“所有东西都全局”，而是：核心逻辑一次，实例化多次。
functions.lua拆分成两部分，一个位于全局位置，一个位于每个工作簿同目录下。全局模块更新，所有vm更新，，局部模块更新，只更新该工作簿的。更新尽量别重载vm。

推荐结构
Core 模块（全局唯一）
  调度器
  菜单
  公共工具
  抽象接口（IRuntime）
Runtime 模块（每工作簿实例）
  Lua VM
  TaskTable
  functions.lua
  热更新策略

只将需要修改的代码给我，简单修改告诉我在哪就行，复杂的就函数替换。