' ============================================
' Excel-Lua 5.4 é›†æˆæ¨¡å—ï¼ˆå®Œæ•´ç‰ˆ + åç¨‹æ”¯æŒï¼‰
' ä½¿ç”¨çº¯ DLL è°ƒç”¨æ–¹å¼
' ============================================

Option Explicit

' ===== Lua 5.4 DLL å£°æ˜ =====
#If VBA7 Then
    ' åŸºç¡€ API
    Private Declare PtrSafe Function luaL_newstate Lib "lua54.dll" () As LongPtr
    Private Declare PtrSafe Sub luaL_openlibs Lib "lua54.dll" (ByVal L As LongPtr)
    Private Declare PtrSafe Sub lua_close Lib "lua54.dll" (ByVal L As LongPtr)
    Private Declare PtrSafe Function luaL_loadstring Lib "lua54.dll" (ByVal L As LongPtr, ByVal s As String) As Long
    Private Declare PtrSafe Function lua_pcallk Lib "lua54.dll" (ByVal L As LongPtr, ByVal nargs As Long, ByVal nResults As Long, ByVal msgh As Long, ByVal ctx As LongPtr, ByVal k As LongPtr) As Long
    Private Declare PtrSafe Function lua_tonumberx Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal isnum As LongPtr) As Double
    Private Declare PtrSafe Function lua_tolstring Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal leng As LongPtr) As LongPtr
    Private Declare PtrSafe Function lua_toboolean Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long) As Long
    Private Declare PtrSafe Function lua_type Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long) As Long
    Private Declare PtrSafe Sub lua_pushnil Lib "lua54.dll" (ByVal L As LongPtr)
    Private Declare PtrSafe Sub lua_pushnumber Lib "lua54.dll" (ByVal L As LongPtr, ByVal n As Double)
    Private Declare PtrSafe Sub lua_pushstring Lib "lua54.dll" (ByVal L As LongPtr, ByVal s As String)
    Private Declare PtrSafe Sub lua_pushboolean Lib "lua54.dll" (ByVal L As LongPtr, ByVal b As Long)
    Private Declare PtrSafe Function lua_gettop Lib "lua54.dll" (ByVal L As LongPtr) As Long
    Private Declare PtrSafe Sub lua_settop Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long)
    Private Declare PtrSafe Function lua_getglobal Lib "lua54.dll" (ByVal L As LongPtr, ByVal name As String) As Long
    Private Declare PtrSafe Sub lua_createtable Lib "lua54.dll" (ByVal L As LongPtr, ByVal narr As Long, ByVal nrec As Long)
    Private Declare PtrSafe Sub lua_rawseti Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal n As LongPtr)
    Private Declare PtrSafe Function lua_rawgeti Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal n As LongPtr) As Long
    Private Declare PtrSafe Function lua_rawlen Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long) As LongPtr
    Private Declare PtrSafe Function luaL_loadfilex Lib "lua54.dll" (ByVal L As LongPtr, ByVal filename As String, ByVal mode As LongPtr) As Long
    Private Declare PtrSafe Sub lua_setglobal Lib "lua54.dll" (ByVal L As LongPtr, ByVal name As String)
    Private Declare PtrSafe Function lua_next Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long) As Long
    Private Declare PtrSafe Sub lua_pushvalue Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long)
    Private Declare PtrSafe Function lua_getfield Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal k As String) As Long
    
    ' åç¨‹ API
    Private Declare PtrSafe Function lua_newthread Lib "lua54.dll" (ByVal L As LongPtr) As LongPtr
    Private Declare PtrSafe Function lua_resume Lib "lua54.dll" (ByVal L As LongPtr, ByVal from As LongPtr, ByVal narg As Long, ByVal nres As LongPtr) As Long
    Private Declare PtrSafe Function lua_status Lib "lua54.dll" (ByVal L As LongPtr) As Long
    Private Declare PtrSafe Sub lua_xmove Lib "lua54.dll" (ByVal fromL As LongPtr, ByVal toL As LongPtr, ByVal n As Long)
    
    ' ç³»ç»Ÿ API
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal length As LongPtr)
    Private Declare PtrSafe Function lstrlenA Lib "kernel32" (ByVal ptr As LongPtr) As Long
    
    Private Type LuaState
        L As LongPtr
        functionsPath As String
        lastModified As Date
    End Type
    
    ' åç¨‹ä»»åŠ¡çŠ¶æ€ - ä¸ä½¿ç”¨ Typeï¼Œæ”¹ç”¨å¤šä¸ª Dictionary
    ' æ¯ä¸ª Dictionary çš„ key éƒ½æ˜¯ taskId
#Else
    ' 32ä½ç‰ˆæœ¬å£°æ˜ï¼ˆç•¥ï¼‰
    Private Type LuaState
        L As Long
        functionsPath As String
        lastModified As Date
    End Type
    
    Private Type TaskState
        taskId As String
        func As String
        startArgs As Variant
        resumeSpec As Variant
        dynamicTargets As Variant
        writeTargets As Variant
        taskCell As String
        status As String
        progress As Double
        message As Variant
        value As Variant
        errMsg As String
        coThread As Long
        lastResumeTime As Double
    End Type
#End If

' ===== Lua ç±»å‹å¸¸é‡ =====
Private Const LUA_TNIL = 0
Private Const LUA_TBOOLEAN = 1
Private Const LUA_TNUMBER = 3
Private Const LUA_TSTRING = 4
Private Const LUA_TTABLE = 5
Private Const LUA_TFUNCTION = 6

' ===== Lua çŠ¶æ€å¸¸é‡ =====
Private Const LUA_OK = 0
Private Const LUA_YIELD = 1
Private Const LUA_ERRRUN = 2

' ===== å…¨å±€å˜é‡ =====
Private g_LuaState As LuaState
Private g_Initialized As Boolean
Private g_HotReloadEnabled As Boolean

' ===== åç¨‹å…¨å±€å˜é‡ =====
Private g_TaskFunc As Object           ' taskId -> func name
Private g_TaskStartArgs As Object      ' taskId -> startArgs array
Private g_TaskResumeSpec As Object     ' taskId -> resumeSpec array
Private g_TaskDynamicTargets As Object ' taskId -> dynamicTargets array
Private g_TaskWriteTargets As Object   ' taskId -> writeTargets array
Private g_TaskCell As Object           ' taskId -> taskCell address
Private g_TaskStatus As Object         ' taskId -> status string
Private g_TaskProgress As Object       ' taskId -> progress number
Private g_TaskMessage As Object        ' taskId -> message variant
Private g_TaskValue As Object          ' taskId -> value variant
Private g_TaskError As Object          ' taskId -> error message
Private g_TaskCoThread As Object       ' taskId -> coThread LongPtr
Private g_TaskQueue As Object          ' taskId -> True (active tasks)
Private g_SchedulerRunning As Boolean
Private g_TimeSliceMs As Long
Private g_NextTaskId As Long

' ===== é…ç½®å¸¸é‡ =====
Private Const DEFAULT_HOT_RELOAD_ENABLED As Boolean = True
Private Const DEFAULT_TIME_SLICE_MS As Long = 100
Private Const SCHEDULER_INTERVAL_SEC As Double = 2  ' æ”¹ä¸º2ç§’ï¼Œå‡å°‘é¢‘ç‡
Private Const MAX_ITERATIONS_PER_TICK As Long = 1   ' æ¯æ¬¡è°ƒåº¦åªæ‰§è¡Œ1æ¬¡è¿­ä»£


' ============================================
' ç¬¬ä¸€éƒ¨åˆ†ï¼šæ ¸å¿ƒåˆå§‹åŒ–å’Œæ¸…ç†
' ============================================

' ä¸»åˆå§‹åŒ–å‡½æ•°ï¼šåˆ›å»ºç©ºç™½ Lua çŠ¶æ€æœº
Private Function InitLuaState() As Boolean
    On Error GoTo ErrorHandler
    
    ' å¦‚æœå·²åˆå§‹åŒ–ï¼Œç›´æ¥è¿”å›æˆåŠŸ
    If g_Initialized Then
        InitLuaState = True
        Exit Function
    End If
    
    ' åˆ›å»ºæ–°çš„ Lua çŠ¶æ€æœº
    g_LuaState.L = luaL_newstate()
    If g_LuaState.L = 0 Then
        MsgBox "æ— æ³•åˆ›å»º Lua çŠ¶æ€æœºã€‚" & vbCrLf & _
               "è¯·ç¡®ä¿ lua54.dll åœ¨ç³»ç»Ÿè·¯å¾„ä¸­ã€‚", vbCritical, "åˆå§‹åŒ–å¤±è´¥"
        InitLuaState = False
        Exit Function
    End If
    
    ' åŠ è½½ Lua æ ‡å‡†åº“
    luaL_openlibs g_LuaState.L
    
    ' è®¾ç½® functions.lua è·¯å¾„
    g_LuaState.functionsPath = ThisWorkbook.Path & "\functions.lua"
    g_LuaState.lastModified = #1/1/1900#
    
    ' æ ‡è®°ä¸ºå·²åˆå§‹åŒ–
    g_Initialized = True
    g_HotReloadEnabled = DEFAULT_HOT_RELOAD_ENABLED
    
    ' åˆå§‹åŒ–åç¨‹ç³»ç»Ÿ
    InitCoroutineSystem
    
    ' å°è¯•é¦–æ¬¡åŠ è½½ functions.luaï¼ˆå¤±è´¥ä¸å½±å“ç»§ç»­ï¼‰
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    If fso.FileExists(g_LuaState.functionsPath) Then
        If TryLoadFunctionsFile() Then
            ' åŠ è½½æˆåŠŸï¼Œé™é»˜å¤„ç†
        Else
            MsgBox "functions.lua åŠ è½½å¤±è´¥ã€‚" & vbCrLf & _
                   "Lua å¼•æ“å·²å¯åŠ¨ï¼Œä½†è‡ªå®šä¹‰å‡½æ•°ä¸å¯ç”¨ã€‚" & vbCrLf & _
                   "è¯·æ£€æŸ¥æ–‡ä»¶è¯­æ³•åæ‰‹åŠ¨é‡è½½ã€‚", vbExclamation, "åˆå§‹åŒ–è­¦å‘Š"
        End If
    End If
    
    InitLuaState = True
    Exit Function

ErrorHandler:
    MsgBox "åˆå§‹åŒ– Lua å¤±è´¥: " & Err.Description, vbCritical, "ä¸¥é‡é”™è¯¯"
    InitLuaState = False
End Function

' åˆå§‹åŒ–åç¨‹ç³»ç»Ÿ
Private Sub InitCoroutineSystem()
    If g_TaskFunc Is Nothing Then
        Set g_TaskFunc = CreateObject("Scripting.Dictionary")
        Set g_TaskStartArgs = CreateObject("Scripting.Dictionary")
        Set g_TaskResumeSpec = CreateObject("Scripting.Dictionary")
        Set g_TaskDynamicTargets = CreateObject("Scripting.Dictionary")
        Set g_TaskWriteTargets = CreateObject("Scripting.Dictionary")
        Set g_TaskCell = CreateObject("Scripting.Dictionary")
        Set g_TaskStatus = CreateObject("Scripting.Dictionary")
        Set g_TaskProgress = CreateObject("Scripting.Dictionary")
        Set g_TaskMessage = CreateObject("Scripting.Dictionary")
        Set g_TaskValue = CreateObject("Scripting.Dictionary")
        Set g_TaskError = CreateObject("Scripting.Dictionary")
        Set g_TaskCoThread = CreateObject("Scripting.Dictionary")
        Set g_TaskQueue = CreateObject("Scripting.Dictionary")
    End If
    
    g_TimeSliceMs = DEFAULT_TIME_SLICE_MS
    g_NextTaskId = 1
End Sub

' æ¸…ç† Lua çŠ¶æ€æœº
Public Sub CleanupLua()
    If g_Initialized Then
        ' åœæ­¢è°ƒåº¦å™¨
        g_SchedulerRunning = False
        
        ' æ¸…ç†æ‰€æœ‰åç¨‹
        If Not g_TaskFunc Is Nothing Then
            g_TaskFunc.RemoveAll
            g_TaskStartArgs.RemoveAll
            g_TaskResumeSpec.RemoveAll
            g_TaskDynamicTargets.RemoveAll
            g_TaskWriteTargets.RemoveAll
            g_TaskCell.RemoveAll
            g_TaskStatus.RemoveAll
            g_TaskProgress.RemoveAll
            g_TaskMessage.RemoveAll
            g_TaskValue.RemoveAll
            g_TaskError.RemoveAll
            g_TaskCoThread.RemoveAll
            g_TaskQueue.RemoveAll
        End If
        
        ' å…³é—­ Lua
        lua_close g_LuaState.L
        g_LuaState.L = 0
        g_Initialized = False
    End If
End Sub

' å·¥ä½œç°¿å…³é—­æ—¶è‡ªåŠ¨æ¸…ç†
Private Sub Workbook_BeforeClose(Cancel As Boolean)
    CleanupLua
End Sub


' ============================================
' ç¬¬äºŒéƒ¨åˆ†ï¼šfunctions.lua åŠ è½½å’Œçƒ­é‡è½½
' ============================================

' åœ¨ä¸´æ—¶çŠ¶æ€ä¸­éªŒè¯ functions.lua è¯­æ³•
Private Function ValidateFunctionsFile() As Boolean
    On Error GoTo ErrorHandler
    
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    If Not fso.FileExists(g_LuaState.functionsPath) Then
        ValidateFunctionsFile = False
        Exit Function
    End If
    
    ' åˆ›å»ºä¸´æ—¶ Lua çŠ¶æ€
    Dim tempL As LongPtr
    tempL = luaL_newstate()
    If tempL = 0 Then
        ValidateFunctionsFile = False
        Exit Function
    End If
    
    luaL_openlibs tempL
    
    ' å°è¯•åŠ è½½å’Œæ‰§è¡Œ
    Dim result As Long
    result = luaL_loadfilex(tempL, g_LuaState.functionsPath, 0)
    If result = 0 Then result = lua_pcallk(tempL, 0, 0, 0, 0, 0)
    
    ' æ£€æŸ¥ç»“æœ
    If result <> 0 Then
        Dim errMsg As String
        errMsg = GetStringFromState(tempL, -1)
        lua_close tempL
        
        MsgBox "functions.lua å­˜åœ¨è¯­æ³•é”™è¯¯ï¼š" & vbCrLf & vbCrLf & _
               errMsg, vbCritical, "æ–‡ä»¶éªŒè¯å¤±è´¥"
        ValidateFunctionsFile = False
        Exit Function
    End If
    
    lua_close tempL
    ValidateFunctionsFile = True
    Exit Function

ErrorHandler:
    If tempL <> 0 Then lua_close tempL
    ValidateFunctionsFile = False
End Function

' åœ¨ä¸»çŠ¶æ€ä¸­åŠ è½½ functions.lua
Private Function LoadFunctionsIntoMainState() As Boolean
    On Error GoTo ErrorHandler
    
    Dim topBefore As Long
    topBefore = lua_gettop(g_LuaState.L)
    
    Dim result As Long
    result = luaL_loadfilex(g_LuaState.L, g_LuaState.functionsPath, 0)
    If result = 0 Then result = lua_pcallk(g_LuaState.L, 0, 0, 0, 0, 0)
    
    ' æ¢å¤æ ˆ
    lua_settop g_LuaState.L, topBefore
    
    If result <> 0 Then
        Dim errMsg As String
        errMsg = GetStringFromState(g_LuaState.L, -1)
        lua_settop g_LuaState.L, topBefore
        
        MsgBox "ä¸»çŠ¶æ€åŠ è½½ functions.lua å¤±è´¥ï¼š" & vbCrLf & vbCrLf & _
               errMsg, vbCritical, "åŠ è½½å¤±è´¥"
        LoadFunctionsIntoMainState = False
        Exit Function
    End If
    
    ' æ›´æ–°æ—¶é—´æˆ³
    g_LuaState.lastModified = FileDateTime(g_LuaState.functionsPath)
    LoadFunctionsIntoMainState = True
    Exit Function

ErrorHandler:
    MsgBox "åŠ è½½è¿‡ç¨‹å‘ç”Ÿ VBA é”™è¯¯: " & Err.Description, vbCritical, "ä¸¥é‡é”™è¯¯"
    LoadFunctionsIntoMainState = False
End Function

' å°è¯•åŠ è½½ functions.luaï¼ˆå…ˆéªŒè¯ï¼Œå†åŠ è½½ï¼‰
Private Function TryLoadFunctionsFile() As Boolean
    ' ç¬¬ä¸€æ­¥ï¼šéªŒè¯è¯­æ³•
    If Not ValidateFunctionsFile() Then
        TryLoadFunctionsFile = False
        Exit Function
    End If
    
    ' ç¬¬äºŒæ­¥ï¼šåŠ è½½åˆ°ä¸»çŠ¶æ€
    TryLoadFunctionsFile = LoadFunctionsIntoMainState()
End Function

' æ£€æŸ¥æ–‡ä»¶æ˜¯å¦éœ€è¦é‡è½½
Private Function NeedsReload() As Boolean
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    ' æ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ— éœ€é‡è½½
    If Not fso.FileExists(g_LuaState.functionsPath) Then
        NeedsReload = False
        Exit Function
    End If
    
    ' æ¯”è¾ƒä¿®æ”¹æ—¶é—´
    Dim currentModified As Date
    currentModified = FileDateTime(g_LuaState.functionsPath)
    NeedsReload = (currentModified <> g_LuaState.lastModified)
End Function

' è‡ªåŠ¨çƒ­é‡è½½æ£€æŸ¥ï¼ˆå¦‚æœå¯ç”¨ï¼‰
Private Sub CheckAutoReload()
    ' æœªå¯ç”¨çƒ­é‡è½½ï¼Œç›´æ¥è¿”å›
    If Not g_HotReloadEnabled Then Exit Sub
    
    ' ä¸éœ€è¦é‡è½½ï¼Œç›´æ¥è¿”å›
    If Not NeedsReload() Then Exit Sub
    
    ' æ‰§è¡Œé‡è½½ï¼ˆå¤±è´¥ä¹Ÿä¸å½±å“ç»§ç»­ä½¿ç”¨æ—§çŠ¶æ€ï¼‰
    If TryLoadFunctionsFile() Then
        ' æˆåŠŸï¼Œé™é»˜å¤„ç†
    Else
        ' å¤±è´¥æ—¶å·²æœ‰å¼¹çª—æç¤ºï¼Œè¿™é‡Œä¸å†å¤„ç†
    End If
End Sub


' ============================================
' ç¬¬ä¸‰éƒ¨åˆ†ï¼šå…¬å…±æ¥å£ï¼ˆåŸºç¡€åŠŸèƒ½ï¼‰
' ============================================

' æ‰§è¡Œ Lua è¡¨è¾¾å¼
Public Function LuaEval(expression As String) As Variant
    On Error GoTo ErrorHandler
    
    ' ç¡®ä¿åˆå§‹åŒ–
    If Not InitLuaState() Then
        LuaEval = CVErr(xlErrValue)
        Exit Function
    End If
    
    ' æ£€æŸ¥çƒ­é‡è½½
    CheckAutoReload
    
    ' æ„é€ ä»£ç 
    Dim fullCode As String
    fullCode = "return " & expression
    
    ' åŠ è½½ä»£ç 
    Dim result As Long
    result = luaL_loadstring(g_LuaState.L, fullCode)
    If result <> 0 Then
        LuaEval = "è¯­æ³•é”™è¯¯: " & GetStringFromState(g_LuaState.L, -1)
        lua_settop g_LuaState.L, 0
        Exit Function
    End If
    
    ' æ‰§è¡Œä»£ç 
    result = lua_pcallk(g_LuaState.L, 0, 1, 0, 0, 0)
    If result <> 0 Then
        LuaEval = "è¿è¡Œé”™è¯¯: " & GetStringFromState(g_LuaState.L, -1)
        lua_settop g_LuaState.L, 0
        Exit Function
    End If
    
    ' è·å–ç»“æœ
    LuaEval = GetValue(g_LuaState.L, -1)
    lua_settop g_LuaState.L, 0
    Exit Function

ErrorHandler:
    LuaEval = "VBAé”™è¯¯: " & Err.Description
    If g_Initialized Then lua_settop g_LuaState.L, 0
End Function

' è°ƒç”¨ functions.lua ä¸­çš„å‡½æ•°
Public Function LuaCall(funcName As String, ParamArray args() As Variant) As Variant
    On Error GoTo ErrorHandler
    
    ' ç¡®ä¿åˆå§‹åŒ–
    If Not InitLuaState() Then
        LuaCall = CVErr(xlErrValue)
        Exit Function
    End If
    
    ' æ£€æŸ¥çƒ­é‡è½½
    CheckAutoReload
    
    ' è·å–å‡½æ•°
    lua_getglobal g_LuaState.L, funcName
    If lua_type(g_LuaState.L, -1) <> LUA_TFUNCTION Then
        lua_settop g_LuaState.L, 0
        LuaCall = "é”™è¯¯: å‡½æ•° '" & funcName & "' ä¸å­˜åœ¨"
        Exit Function
    End If
    
    ' æ¨å…¥å‚æ•°
    Dim i As Long, argCount As Long
    argCount = 0
    For i = LBound(args) To UBound(args)
        If TypeName(args(i)) = "Range" Then
            PushRangeValue g_LuaState.L, args(i)
        Else
            PushValue g_LuaState.L, args(i)
        End If
        argCount = argCount + 1
    Next i
    
    ' è°ƒç”¨å‡½æ•°
    Dim result As Long
    result = lua_pcallk(g_LuaState.L, argCount, -1, 0, 0, 0)
    If result <> 0 Then
        LuaCall = "è¿è¡Œé”™è¯¯: " & GetStringFromState(g_LuaState.L, -1)
        lua_settop g_LuaState.L, 0
        Exit Function
    End If
    
    ' å¤„ç†è¿”å›å€¼
    Dim nResults As Long
    nResults = lua_gettop(g_LuaState.L)
    
    If nResults = 0 Then
        LuaCall = Empty
    ElseIf nResults = 1 Then
        LuaCall = GetValue(g_LuaState.L, -1)
    Else
        ' å¤šä¸ªè¿”å›å€¼
        Dim results() As Variant
        ReDim results(1 To 1, 1 To nResults)
        For i = 1 To nResults
            results(1, i) = GetValue(g_LuaState.L, i)
        Next i
        LuaCall = results
    End If
    
    lua_settop g_LuaState.L, 0
    Exit Function

ErrorHandler:
    LuaCall = "VBAé”™è¯¯: " & Err.Description
    If g_Initialized Then lua_settop g_LuaState.L, 0
End Function

' æ‰‹åŠ¨é‡è½½ functions.lua
Public Function ReloadFunctions() As Boolean
    If Not g_Initialized Then
        If Not InitLuaState() Then
            MsgBox "æ— æ³•åˆå§‹åŒ– Lua å¼•æ“ã€‚", vbCritical, "é‡è½½å¤±è´¥"
            ReloadFunctions = False
            Exit Function
        End If
    End If
    
    If TryLoadFunctionsFile() Then
        MsgBox "functions.lua å·²æˆåŠŸé‡è½½ï¼", vbInformation, "é‡è½½æˆåŠŸ"
        ReloadFunctions = True
    Else
        MsgBox "functions.lua é‡è½½å¤±è´¥ã€‚" & vbCrLf & _
               "è¯·æ£€æŸ¥æ–‡ä»¶è¯­æ³•ã€‚", vbCritical, "é‡è½½å¤±è´¥"
        ReloadFunctions = False
    End If
End Function

' å¯ç”¨çƒ­é‡è½½
Public Sub EnableHotReload()
    g_HotReloadEnabled = True
    MsgBox "Lua è‡ªåŠ¨çƒ­é‡è½½å·²å¯ç”¨ã€‚" & vbCrLf & _
           "å½“ functions.lua ä¿®æ”¹åï¼Œç³»ç»Ÿå°†è‡ªåŠ¨é‡æ–°åŠ è½½ã€‚", _
           vbInformation, "çƒ­é‡è½½å·²å¯ç”¨"
End Sub

' ç¦ç”¨çƒ­é‡è½½
Public Sub DisableHotReload()
    g_HotReloadEnabled = False
    MsgBox "Lua è‡ªåŠ¨çƒ­é‡è½½å·²ç¦ç”¨ã€‚" & vbCrLf & _
           "å¦‚éœ€æ›´æ–° functions.luaï¼Œè¯·æ‰‹åŠ¨è¿è¡Œ ""ReloadFunctions""ã€‚", _
           vbExclamation, "çƒ­é‡è½½å·²ç¦ç”¨"
End Sub

' æ˜¾ç¤ºæ‰€æœ‰ä»»åŠ¡ä¿¡æ¯
Public Sub ShowAllTasks()
    On Error GoTo ErrorHandler
    
    If g_TaskFunc Is Nothing Then
        InitCoroutineSystem
    End If
    
    If g_TaskFunc.Count = 0 Then
        MsgBox "å½“å‰æ²¡æœ‰ä»»ä½•ä»»åŠ¡ã€‚", vbInformation, "ä»»åŠ¡åˆ—è¡¨"
        Exit Sub
    End If
    
    ' æ„å»ºä»»åŠ¡ä¿¡æ¯å­—ç¬¦ä¸²
    Dim msg As String
    Dim taskId As Variant
    Dim taskCount As Long
    Dim runningCount As Long, yieldedCount As Long, doneCount As Long, errorCount As Long
    
    msg = "========================================" & vbCrLf
    msg = msg & "  Lua åç¨‹ä»»åŠ¡ç®¡ç†å™¨" & vbCrLf
    msg = msg & "========================================" & vbCrLf & vbCrLf
    
    msg = msg & "ä»»åŠ¡æ€»æ•°: " & g_TaskFunc.Count & vbCrLf
    msg = msg & "æ´»è·ƒé˜Ÿåˆ—: " & g_TaskQueue.Count & vbCrLf
    msg = msg & "è°ƒåº¦å™¨: " & IIf(g_SchedulerRunning, "è¿è¡Œä¸­ âœ“", "å·²åœæ­¢ âœ—") & vbCrLf
    msg = msg & vbCrLf & "----------------------------------------" & vbCrLf & vbCrLf
    
    ' ç»Ÿè®¡å„çŠ¶æ€ä»»åŠ¡æ•°
    For Each taskId In g_TaskFunc.Keys
        Select Case g_TaskStatus(CStr(taskId))
            Case "running": runningCount = runningCount + 1
            Case "yielded": yieldedCount = yieldedCount + 1
            Case "done": doneCount = doneCount + 1
            Case "error": errorCount = errorCount + 1
        End Select
    Next taskId
    
    msg = msg & "çŠ¶æ€ç»Ÿè®¡:" & vbCrLf
    msg = msg & " â€¢ è¿è¡Œä¸­: " & runningCount & vbCrLf
    msg = msg & " â€¢ æš‚åœä¸­: " & yieldedCount & vbCrLf
    msg = msg & " â€¢ å·²å®Œæˆ: " & doneCount & vbCrLf
    msg = msg & " â€¢ é”™è¯¯: " & errorCount & vbCrLf
    msg = msg & vbCrLf & "========================================" & vbCrLf & vbCrLf
    
    ' è¯¦ç»†åˆ—å‡ºæ¯ä¸ªä»»åŠ¡
    taskCount = 0
    For Each taskId In g_TaskFunc.Keys
        taskCount = taskCount + 1
        msg = msg & "ã€ä»»åŠ¡ #" & taskCount & "ã€‘" & vbCrLf
        msg = msg & "  ID: " & CStr(taskId) & vbCrLf
        msg = msg & "  å‡½æ•°: " & g_TaskFunc(CStr(taskId)) & vbCrLf
        msg = msg & "  å•å…ƒæ ¼: " & g_TaskCell(CStr(taskId)) & vbCrLf
        msg = msg & "  çŠ¶æ€: " & GetStatusIcon(g_TaskStatus(CStr(taskId))) & " " & g_TaskStatus(CStr(taskId)) & vbCrLf
        msg = msg & "  è¿›åº¦: " & Format(g_TaskProgress(CStr(taskId)), "0.0") & "%" & vbCrLf
        
        ' æ˜¾ç¤ºæ¶ˆæ¯
        Dim msgText As String
        msgText = CStr(g_TaskMessage(CStr(taskId)))
        If Len(msgText) > 50 Then msgText = Left(msgText, 47) & "..."
        msg = msg & "  æ¶ˆæ¯: " & msgText & vbCrLf
        
        ' å¦‚æœæœ‰é”™è¯¯ï¼Œæ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
        If g_TaskStatus(CStr(taskId)) = "error" Then
            Dim errText As String
            errText = CStr(g_TaskError(CStr(taskId)))
            If Len(errText) > 60 Then errText = Left(errText, 57) & "..."
            msg = msg & "   é”™è¯¯: " & errText & vbCrLf
        End If
        
        ' æ˜¾ç¤ºæ˜¯å¦åœ¨æ´»è·ƒé˜Ÿåˆ—ä¸­
        If g_TaskQueue.Exists(CStr(taskId)) Then
            msg = msg & "  é˜Ÿåˆ—: æ˜¯" & vbCrLf
        End If
        
        msg = msg & "----------------------------------------" & vbCrLf
    Next taskId
    
    ' æ˜¾ç¤ºæ¶ˆæ¯æ¡†
    MsgBox msg, vbInformation, "Lua åç¨‹ä»»åŠ¡åˆ—è¡¨ (" & g_TaskFunc.Count & " ä¸ªä»»åŠ¡)"
    
    Exit Sub

ErrorHandler:
    MsgBox "æ˜¾ç¤ºä»»åŠ¡ä¿¡æ¯æ—¶å‡ºé”™: " & Err.Description, vbCritical, "é”™è¯¯"
End Sub

' è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®çŠ¶æ€è¿”å›å›¾æ ‡
Private Function GetStatusIcon(status As String) As String
    Select Case LCase(status)
        Case "defined": GetStatusIcon = "ğŸ“‹"
        Case "running": GetStatusIcon = "â–¶ï¸"
        Case "yielded": GetStatusIcon = "â¸ï¸"
        Case "done": GetStatusIcon = "âœ…"
        Case "error": GetStatusIcon = "âŒ"
        Case Else: GetStatusIcon = "â“"
    End Select
End Function

' æ˜¾ç¤ºå•ä¸ªä»»åŠ¡çš„è¯¦ç»†ä¿¡æ¯
Public Sub ShowTaskDetail(taskId As String)
    On Error GoTo ErrorHandler
    
    If g_TaskFunc Is Nothing Then
        InitCoroutineSystem
    End If
    
    If Not g_TaskFunc.Exists(taskId) Then
        MsgBox "ä»»åŠ¡ " & taskId & " ä¸å­˜åœ¨ï¼", vbCritical, "é”™è¯¯"
        Exit Sub
    End If
    
    Dim msg As String
    msg = "========================================" & vbCrLf
    msg = msg & "  ä»»åŠ¡è¯¦ç»†ä¿¡æ¯" & vbCrLf
    msg = msg & "========================================" & vbCrLf & vbCrLf
    
    msg = msg & "ä»»åŠ¡ID: " & taskId & vbCrLf
    msg = msg & "å‡½æ•°å: " & g_TaskFunc(taskId) & vbCrLf
    msg = msg & "å•å…ƒæ ¼: " & g_TaskCell(taskId) & vbCrLf
    msg = msg & "çŠ¶æ€: " & GetStatusIcon(g_TaskStatus(taskId)) & " " & g_TaskStatus(taskId) & vbCrLf
    msg = msg & "è¿›åº¦: " & Format(g_TaskProgress(taskId), "0.00") & "%" & vbCrLf
    msg = msg & "æ¶ˆæ¯: " & CStr(g_TaskMessage(taskId)) & vbCrLf
    msg = msg & vbCrLf & "----------------------------------------" & vbCrLf & vbCrLf
    
    ' å¯åŠ¨å‚æ•°
    msg = msg & "å¯åŠ¨å‚æ•°:" & vbCrLf
    Dim startArgs As Variant
    startArgs = g_TaskStartArgs(taskId)
    If IsArray(startArgs) Then
        Dim i As Long
        For i = LBound(startArgs) To UBound(startArgs)
            msg = msg & "   [" & i & "] " & CStr(startArgs(i)) & vbCrLf
        Next i
    Else
        msg = msg & "   (æ— )" & vbCrLf
    End If
    
    ' Resume å‚æ•°
    msg = msg & vbCrLf & "Resume å‚æ•°:" & vbCrLf
    Dim resumeSpec As Variant
    resumeSpec = g_TaskResumeSpec(taskId)
    If IsArray(resumeSpec) Then
        For i = LBound(resumeSpec) To UBound(resumeSpec)
            msg = msg & "   [" & i & "] " & CStr(resumeSpec(i)) & vbCrLf
        Next i
    Else
        msg = msg & "   (æ— )" & vbCrLf
    End If
    
    ' å†™å…¥ç›®æ ‡
    msg = msg & vbCrLf & "åŠ¨æ€å†™å…¥ç›®æ ‡:" & vbCrLf
    Dim dynamicTargets As Variant
    dynamicTargets = g_TaskDynamicTargets(taskId)
    If IsArray(dynamicTargets) Then
        For i = LBound(dynamicTargets) To UBound(dynamicTargets)
            msg = msg & "   â€¢ " & CStr(dynamicTargets(i)) & vbCrLf
        Next i
    Else
        msg = msg & "   (æ— )" & vbCrLf
    End If
    
    msg = msg & vbCrLf & "æœ€ç»ˆå†™å…¥ç›®æ ‡:" & vbCrLf
    Dim writeTargets As Variant
    writeTargets = g_TaskWriteTargets(taskId)
    If IsArray(writeTargets) Then
        For i = LBound(writeTargets) To UBound(writeTargets)
            msg = msg & "   â€¢ " & CStr(writeTargets(i)) & vbCrLf
        Next i
    Else
        msg = msg & "   (æ— )" & vbCrLf
    End If
    
    ' å½“å‰å€¼
    msg = msg & vbCrLf & "å½“å‰å€¼:" & vbCrLf
    Dim value As Variant
    value = g_TaskValue(taskId)
    If IsArray(value) Then
        msg = msg & "   (æ•°ç»„ï¼Œç»´åº¦: " & ArrayDimensions(value) & ")" & vbCrLf
    ElseIf IsEmpty(value) Then
        msg = msg & "   (ç©º)" & vbCrLf
    Else
        Dim valueStr As String
        valueStr = CStr(value)
        If Len(valueStr) > 100 Then valueStr = Left(valueStr, 97) & "..."
        msg = msg & "   " & valueStr & vbCrLf
    End If
    
    ' é”™è¯¯ä¿¡æ¯
    If g_TaskStatus(taskId) = "error" Then
        msg = msg & vbCrLf & " é”™è¯¯ä¿¡æ¯:" & vbCrLf
        msg = msg & "   " & g_TaskError(taskId) & vbCrLf
    End If
    
    ' è°ƒåº¦ä¿¡æ¯
    msg = msg & vbCrLf & "----------------------------------------" & vbCrLf
    msg = msg & "åœ¨æ´»è·ƒé˜Ÿåˆ—ä¸­: " & IIf(g_TaskQueue.Exists(taskId), "æ˜¯ âœ“", "å¦ âœ—") & vbCrLf
    msg = msg & "åç¨‹çº¿ç¨‹: " & IIf(g_TaskCoThread(taskId) = 0, "æœªåˆ›å»º", "0x" & Hex(g_TaskCoThread(taskId))) & vbCrLf
    
    MsgBox msg, vbInformation, "ä»»åŠ¡è¯¦æƒ… - " & taskId
    
    Exit Sub

ErrorHandler:
    MsgBox "æ˜¾ç¤ºä»»åŠ¡è¯¦æƒ…æ—¶å‡ºé”™: " & Err.Description, vbCritical, "é”™è¯¯"
End Sub

' è¾…åŠ©å‡½æ•°ï¼šè·å–æ•°ç»„ç»´åº¦
Private Function ArrayDimensions(arr As Variant) As String
    On Error Resume Next
    Dim dims As String
    Dim i As Long
    
    For i = 1 To 60  ' æœ€å¤šæ£€æŸ¥60ç»´
        Dim ub As Long
        ub = UBound(arr, i)
        If Err.Number <> 0 Then
            Exit For
        End If
        
        Dim lb As Long
        lb = LBound(arr, i)
        
        If dims <> "" Then dims = dims & " x "
        dims = dims & (ub - lb + 1)
    Next i
    
    If dims = "" Then dims = "æœªçŸ¥"
    ArrayDimensions = dims
End Function

' æ¸…ç†æ‰€æœ‰å·²å®Œæˆæˆ–é”™è¯¯çš„ä»»åŠ¡
Public Sub CleanupFinishedTasks()
    On Error Resume Next
    
    If g_TaskFunc Is Nothing Then
        MsgBox "æ²¡æœ‰ä»»åŠ¡éœ€è¦æ¸…ç†ã€‚", vbInformation, "æ¸…ç†ä»»åŠ¡"
        Exit Sub
    End If
    
    Dim taskId As Variant
    Dim tasksToRemove As Object
    Set tasksToRemove = CreateObject("System.Collections.ArrayList")
    
    ' æ”¶é›†éœ€è¦æ¸…ç†çš„ä»»åŠ¡
    For Each taskId In g_TaskFunc.Keys
        Dim status As String
        status = g_TaskStatus(CStr(taskId))
        If status = "done" Or status = "error" Then
            tasksToRemove.Add taskId
        End If
    Next taskId
    
    ' æ¸…ç†ä»»åŠ¡
    Dim i As Long
    For i = 0 To tasksToRemove.Count - 1
        Dim tid As String
        tid = CStr(tasksToRemove(i))
        
        g_TaskFunc.Remove tid
        g_TaskStartArgs.Remove tid
        g_TaskResumeSpec.Remove tid
        g_TaskDynamicTargets.Remove tid
        g_TaskWriteTargets.Remove tid
        g_TaskCell.Remove tid
        g_TaskStatus.Remove tid
        g_TaskProgress.Remove tid
        g_TaskMessage.Remove tid
        g_TaskValue.Remove tid
        g_TaskError.Remove tid
        g_TaskCoThread.Remove tid
        
        If g_TaskQueue.Exists(tid) Then
            g_TaskQueue.Remove tid
        End If
    Next i
    
    MsgBox "å·²æ¸…ç† " & tasksToRemove.Count & " ä¸ªå·²å®Œæˆæˆ–é”™è¯¯çš„ä»»åŠ¡ã€‚" & vbCrLf & _
           "å‰©ä½™ä»»åŠ¡: " & g_TaskFunc.Count, vbInformation, "æ¸…ç†å®Œæˆ"
End Sub

' æ‰‹åŠ¨åœæ­¢è°ƒåº¦å™¨
Public Sub StopScheduler()
    g_SchedulerRunning = False
    
    ' å°è¯•å–æ¶ˆæ‰€æœ‰ OnTime è°ƒåº¦
    On Error Resume Next
    Application.OnTime Now + TimeValue("00:00:01") * SCHEDULER_INTERVAL_SEC, "SchedulerTick", , False
    
    MsgBox "è°ƒåº¦å™¨å·²åœæ­¢ã€‚" & vbCrLf & _
           "æ´»è·ƒä»»åŠ¡å°†ä¿æŒåœ¨é˜Ÿåˆ—ä¸­ï¼Œä¸ä¼šç»§ç»­æ‰§è¡Œã€‚" & vbCrLf & vbCrLf & _
           "ä½¿ç”¨ ResumeScheduler é‡æ–°å¯åŠ¨ã€‚", vbInformation, "è°ƒåº¦å™¨å·²åœæ­¢"
End Sub

' æ¢å¤è°ƒåº¦å™¨
Public Sub ResumeScheduler()
    If g_TaskQueue Is Nothing Or g_TaskQueue.Count = 0 Then
        MsgBox "é˜Ÿåˆ—ä¸­æ²¡æœ‰ä»»åŠ¡ï¼Œæ— éœ€å¯åŠ¨è°ƒåº¦å™¨ã€‚", vbExclamation, "æ— ä»»åŠ¡"
        Exit Sub
    End If
    
    If g_SchedulerRunning Then
        MsgBox "è°ƒåº¦å™¨å·²åœ¨è¿è¡Œä¸­ã€‚", vbInformation, "è°ƒåº¦å™¨çŠ¶æ€"
        Exit Sub
    End If
    
    g_SchedulerRunning = True
    Application.OnTime Now + TimeValue("00:00:01") * SCHEDULER_INTERVAL_SEC, "SchedulerTick"
    
    MsgBox "è°ƒåº¦å™¨å·²å¯åŠ¨ã€‚" & vbCrLf & _
           "å½“å‰é˜Ÿåˆ—ä»»åŠ¡æ•°: " & g_TaskQueue.Count, vbInformation, "è°ƒåº¦å™¨å·²å¯åŠ¨"
End Sub

' æš‚åœæŒ‡å®šä»»åŠ¡ï¼ˆä»é˜Ÿåˆ—ä¸­ç§»é™¤ï¼Œä½†ä¿ç•™çŠ¶æ€ï¼‰
Public Sub PauseTask(taskId As String)
    If Not g_TaskFunc.Exists(taskId) Then
        MsgBox "ä»»åŠ¡ " & taskId & " ä¸å­˜åœ¨ã€‚", vbCritical, "é”™è¯¯"
        Exit Sub
    End If
    
    If g_TaskQueue.Exists(taskId) Then
        g_TaskQueue.Remove taskId
        MsgBox "ä»»åŠ¡ " & taskId & " å·²æš‚åœã€‚" & vbCrLf & _
               "ä½¿ç”¨ ResumeTask æ¢å¤ã€‚", vbInformation, "ä»»åŠ¡å·²æš‚åœ"
    Else
        MsgBox "ä»»åŠ¡ " & taskId & " ä¸åœ¨æ´»è·ƒé˜Ÿåˆ—ä¸­ã€‚", vbExclamation, "æç¤º"
    End If
End Sub

' æ¢å¤æŒ‡å®šä»»åŠ¡ï¼ˆåŠ å…¥é˜Ÿåˆ—ï¼‰
Public Sub ResumeTask(taskId As String)
    If Not g_TaskFunc.Exists(taskId) Then
        MsgBox "ä»»åŠ¡ " & taskId & " ä¸å­˜åœ¨ã€‚", vbCritical, "é”™è¯¯"
        Exit Sub
    End If
    
    Dim status As String
    status = g_TaskStatus(taskId)
    
    If status <> "yielded" And status <> "running" Then
        MsgBox "ä»»åŠ¡ " & taskId & " çŠ¶æ€ä¸º " & status & "ï¼Œæ— æ³•æ¢å¤ã€‚", vbExclamation, "æ— æ³•æ¢å¤"
        Exit Sub
    End If
    
    If Not g_TaskQueue.Exists(taskId) Then
        g_TaskQueue(taskId) = True
        StartSchedulerIfNeeded
        MsgBox "ä»»åŠ¡ " & taskId & " å·²æ¢å¤ã€‚", vbInformation, "ä»»åŠ¡å·²æ¢å¤"
    Else
        MsgBox "ä»»åŠ¡ " & taskId & " å·²åœ¨æ´»è·ƒé˜Ÿåˆ—ä¸­ã€‚", vbInformation, "æç¤º"
    End If
End Sub

' è®¾ç½®è°ƒåº¦é—´éš”ï¼ˆç§’ï¼‰
Public Sub SetSchedulerInterval(seconds As Double)
    If seconds < 0.1 Then
        MsgBox "é—´éš”ä¸èƒ½å°äº 0.1 ç§’ã€‚", vbExclamation, "æ— æ•ˆå€¼"
        Exit Sub
    End If
    
    If seconds > 60 Then
        MsgBox "é—´éš”ä¸èƒ½å¤§äº 60 ç§’ã€‚", vbExclamation, "æ— æ•ˆå€¼"
        Exit Sub
    End If
    
    ' æ³¨æ„ï¼šè¿™éœ€è¦ä¿®æ”¹å¸¸é‡ï¼Œå®é™…ä½¿ç”¨æ—¶å»ºè®®å°†å¸¸é‡æ”¹ä¸ºå˜é‡
    MsgBox "å½“å‰è°ƒåº¦é—´éš”: " & SCHEDULER_INTERVAL_SEC & " ç§’" & vbCrLf & vbCrLf & _
           "è¦ä¿®æ”¹é—´éš”ï¼Œè¯·åœ¨ä»£ç ä¸­ä¿®æ”¹ SCHEDULER_INTERVAL_SEC å¸¸é‡ã€‚", _
           vbInformation, "è°ƒåº¦é—´éš”"
End Sub

' æ¸…ç©ºæ‰€æœ‰ä»»åŠ¡å’Œé˜Ÿåˆ—
Public Sub ClearAllTasks()
    Dim result As VbMsgBoxResult
    result = MsgBox("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰ä»»åŠ¡å—ï¼Ÿ" & vbCrLf & vbCrLf & _
                    "è¿™å°†åˆ é™¤æ‰€æœ‰ä»»åŠ¡æ•°æ®ï¼Œæ— æ³•æ¢å¤ï¼", _
                    vbExclamation + vbYesNo, "ç¡®è®¤æ¸…ç©º")
    
    If result = vbNo Then Exit Sub
    
    ' åœæ­¢è°ƒåº¦å™¨
    g_SchedulerRunning = False
    
    ' æ¸…ç©ºæ‰€æœ‰ Dictionary
    If Not g_TaskFunc Is Nothing Then
        g_TaskFunc.RemoveAll
        g_TaskStartArgs.RemoveAll
        g_TaskResumeSpec.RemoveAll
        g_TaskDynamicTargets.RemoveAll
        g_TaskWriteTargets.RemoveAll
        g_TaskCell.RemoveAll
        g_TaskStatus.RemoveAll
        g_TaskProgress.RemoveAll
        g_TaskMessage.RemoveAll
        g_TaskValue.RemoveAll
        g_TaskError.RemoveAll
        g_TaskCoThread.RemoveAll
        g_TaskQueue.RemoveAll
    End If
    
    MsgBox "æ‰€æœ‰ä»»åŠ¡å·²æ¸…ç©ºã€‚", vbInformation, "æ¸…ç©ºå®Œæˆ"
End Sub


' ============================================
' ç¬¬å››éƒ¨åˆ†ï¼šåç¨‹ UDF æ¥å£
' ============================================

' ä»»åŠ¡å®šä¹‰å‡½æ•°
Public Function LuaTask(ParamArray params() As Variant) As String
    On Error GoTo ErrorHandler

    If Not InitLuaState() Then
        LuaTask = "#ERROR: Luaæœªåˆå§‹åŒ–"
        Exit Function
    End If

    If UBound(params) < 0 Then
        LuaTask = "#ERROR: éœ€è¦å‡½æ•°å"
        Exit Function
    End If

    ' === è·å–è°ƒç”¨å•å…ƒæ ¼åœ°å€ï¼ˆå¹‚ç­‰é”šç‚¹ï¼‰===
    Dim taskCell As String
    taskCell = Application.Caller.Address(External:=True)

    ' === å¹‚ç­‰æ£€æŸ¥ï¼šè¯¥å•å…ƒæ ¼æ˜¯å¦å·²æœ‰ä»»åŠ¡ ===
    Dim existingTaskId As String
    existingTaskId = FindTaskByCell(taskCell)

    If existingTaskId <> "" Then
        ' å·²å­˜åœ¨ä»»åŠ¡ï¼Œç›´æ¥è¿”å›ï¼Œä¸åšä»»ä½•å‰¯ä½œç”¨
        LuaTask = existingTaskId
        Exit Function
    End If

    ' ===== ä»¥ä¸‹é€»è¾‘ï¼šåªä¼šæ‰§è¡Œä¸€æ¬¡ =====

    Dim funcName As String
    funcName = CStr(params(0))

    Dim startArgs As Variant, resumeSpec As Variant
    Dim dynamicTargets As Variant, writeTargets As Variant
    startArgs = Array()
    resumeSpec = Array()
    dynamicTargets = Array()
    writeTargets = Array()

    Dim phase As Long
    phase = 0

    Dim startList As Object, resumeList As Object
    Dim dynamicList As Object, writeList As Object
    Set startList = CreateObject("System.Collections.ArrayList")
    Set resumeList = CreateObject("System.Collections.ArrayList")
    Set dynamicList = CreateObject("System.Collections.ArrayList")
    Set writeList = CreateObject("System.Collections.ArrayList")

    Dim i As Long
    For i = 1 To UBound(params)
        If VarType(params(i)) = vbString Then
            Select Case params(i)
                Case "|": phase = 1
                Case ">>": phase = 2
                Case "->": phase = 3
                Case Else
                    Select Case phase
                        Case 0: startList.Add params(i)
                        Case 1: resumeList.Add params(i)
                        Case 2: dynamicList.Add params(i)
                        Case 3: writeList.Add params(i)
                    End Select
            End Select
        Else
            Select Case phase
                Case 0: startList.Add params(i)
                Case 1: resumeList.Add params(i)
                Case 2: dynamicList.Add params(i)
                Case 3: writeList.Add params(i)
            End Select
        End If
    Next i

    If startList.Count > 0 Then startArgs = startList.ToArray()
    If resumeList.Count > 0 Then resumeSpec = resumeList.ToArray()
    If dynamicList.Count > 0 Then dynamicTargets = dynamicList.ToArray()
    If writeList.Count > 0 Then writeTargets = writeList.ToArray()

    ' === åˆ›å»ºæ–°ä»»åŠ¡ï¼ˆä»…æ­¤ä¸€æ¬¡ï¼‰===
    Dim taskId As String
    taskId = "TASK_" & g_NextTaskId
    g_NextTaskId = g_NextTaskId + 1

    g_TaskFunc(taskId) = funcName
    g_TaskStartArgs(taskId) = startArgs
    g_TaskResumeSpec(taskId) = resumeSpec
    g_TaskDynamicTargets(taskId) = dynamicTargets
    g_TaskWriteTargets(taskId) = writeTargets
    g_TaskCell(taskId) = taskCell
    g_TaskStatus(taskId) = "defined"
    g_TaskProgress(taskId) = 0
    g_TaskMessage(taskId) = Empty
    g_TaskValue(taskId) = Empty
    g_TaskError(taskId) = ""
    g_TaskCoThread(taskId) = 0

    LuaTask = taskId
    Exit Function

ErrorHandler:
    LuaTask = "#ERROR: " & Err.Description
End Function

' è¯»å–ä»»åŠ¡çŠ¶æ€
Public Function LuaGet(taskId As String, field As String) As Variant
    On Error GoTo ErrorHandler
    
    If g_TaskFunc Is Nothing Then
        InitCoroutineSystem
    End If
    
    If Not g_TaskFunc.Exists(taskId) Then
        LuaGet = "#ERROR: ä»»åŠ¡ä¸å­˜åœ¨"
        Exit Function
    End If
    
    Select Case LCase(field)
        Case "status"
            LuaGet = g_TaskStatus(taskId)
        Case "progress"
            LuaGet = g_TaskProgress(taskId)
        Case "message"
            LuaGet = g_TaskMessage(taskId)
        Case "value"
            LuaGet = g_TaskValue(taskId)
        Case "error"
            LuaGet = g_TaskError(taskId)
        Case Else
            LuaGet = "#ERROR: æœªçŸ¥å­—æ®µ"
    End Select
    
    Exit Function

ErrorHandler:
    LuaGet = "#ERROR: " & Err.Description
End Function


' ============================================
' ç¬¬äº”éƒ¨åˆ†ï¼šåç¨‹æ‰§è¡Œå’Œè°ƒåº¦
' ============================================

' å¯åŠ¨åç¨‹
Public Sub StartLuaCoroutine(taskId As String)
    On Error GoTo ErrorHandler
    
    If g_TaskFunc Is Nothing Then
        InitCoroutineSystem
    End If
    
    If Not g_TaskFunc.Exists(taskId) Then
        MsgBox "é”™è¯¯ï¼šä»»åŠ¡ " & taskId & " ä¸å­˜åœ¨", vbCritical
        Exit Sub
    End If
    
    If g_TaskStatus(taskId) <> "defined" Then
        MsgBox "é”™è¯¯ï¼šä»»åŠ¡å·²å¯åŠ¨æˆ–å·²å®Œæˆ", vbExclamation
        Exit Sub
    End If
    
    ' åˆ›å»ºåç¨‹çº¿ç¨‹
    Dim coThread As LongPtr
    coThread = lua_newthread(g_LuaState.L)
    If coThread = 0 Then
        g_TaskStatus(taskId) = "error"
        g_TaskError(taskId) = "æ— æ³•åˆ›å»ºåç¨‹çº¿ç¨‹"
        Exit Sub
    End If
    
    g_TaskCoThread(taskId) = coThread
    
    ' è·å–åç¨‹å‡½æ•°
    lua_getglobal g_LuaState.L, g_TaskFunc(taskId)
    
    ' ç§»åŠ¨å‡½æ•°åˆ°åç¨‹çº¿ç¨‹
    lua_xmove g_LuaState.L, coThread, 1
    
    ' æ¨å…¥ taskCell ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°
    lua_pushstring coThread, g_TaskCell(taskId)
    
    ' æ¨å…¥å¯åŠ¨å‚æ•°
    Dim i As Long
    Dim startArgs As Variant
    startArgs = g_TaskStartArgs(taskId)
    
    If IsArray(startArgs) Then
        For i = LBound(startArgs) To UBound(startArgs)
            If TypeName(startArgs(i)) = "Range" Then
                PushRangeValueToThread coThread, startArgs(i)
            Else
                PushValueToThread coThread, startArgs(i)
            End If
        Next i
    End If
    
    ' é¦–æ¬¡ resume
    Dim nargs As Long
    nargs = 1  ' taskCell
    If IsArray(startArgs) Then
        nargs = nargs + UBound(startArgs) - LBound(startArgs) + 1
    End If
    
    Dim nres As LongPtr
    Dim result As Long
    result = lua_resume(coThread, g_LuaState.L, nargs, VarPtr(nres))
    
    ' å¤„ç†ç»“æœ
    HandleCoroutineResult taskId, result, CLng(nres)
    
    ' åŠ å…¥è°ƒåº¦é˜Ÿåˆ—
    If g_TaskStatus(taskId) = "running" Or g_TaskStatus(taskId) = "yielded" Then
        g_TaskQueue(taskId) = True
        StartSchedulerIfNeeded
    End If
    
    Exit Sub

ErrorHandler:
    If g_TaskFunc.Exists(taskId) Then
        g_TaskStatus(taskId) = "error"
        g_TaskError(taskId) = "VBAé”™è¯¯: " & Err.Description
    End If
    MsgBox "å¯åŠ¨åç¨‹å¤±è´¥: " & Err.Description, vbCritical
End Sub

' å¯åŠ¨è°ƒåº¦å™¨
Private Sub StartSchedulerIfNeeded()
    If g_SchedulerRunning Then Exit Sub
    If g_TaskQueue Is Nothing Then Exit Sub
    If g_TaskQueue.Count = 0 Then Exit Sub

    g_SchedulerRunning = True
    Application.OnTime _
        Now + TimeSerial(0, 0, SCHEDULER_INTERVAL_SEC), _
        "SchedulerTick"
End Sub


' è°ƒåº¦å™¨å¿ƒè·³
Public Sub SchedulerTick()
    On Error Resume Next

    If g_TaskQueue Is Nothing Or g_TaskQueue.Count = 0 Then
        g_SchedulerRunning = False
        Exit Sub
    End If

    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual

    Dim taskId As Variant
    Dim tasksToRemove As Object
    Set tasksToRemove = CreateObject("System.Collections.ArrayList")

    Dim iterCount As Long

    For Each taskId In g_TaskQueue.Keys
        If iterCount >= MAX_ITERATIONS_PER_TICK Then Exit For

        ResumeCoroutine CStr(taskId)
        iterCount = iterCount + 1

        If g_TaskStatus(taskId) = "done" _
        Or g_TaskStatus(taskId) = "error" Then
            tasksToRemove.Add taskId
        End If
    Next

    Dim i As Long
    For i = 0 To tasksToRemove.Count - 1
        g_TaskQueue.Remove tasksToRemove(i)
    Next

    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    Application.ScreenUpdating = True

    ' === æ˜¯å¦ç»§ç»­ ===
    If g_TaskQueue.Count > 0 Then
        Application.OnTime _
            Now + TimeSerial(0, 0, SCHEDULER_INTERVAL_SEC), _
            "SchedulerTick"
    Else
        g_SchedulerRunning = False
    End If
End Sub

' Resume åç¨‹
Private Sub ResumeCoroutine(taskId As String)
    On Error GoTo ErrorHandler
    
    If g_TaskStatus(taskId) <> "yielded" Then Exit Sub
    
    Dim coThread As LongPtr
    coThread = g_TaskCoThread(taskId)
    
    ' æ¸…ç©ºåç¨‹æ ˆ
    lua_settop coThread, 0
    
    ' æ¨å…¥ resume å‚æ•°
    Dim i As Long
    Dim resumeSpec As Variant
    resumeSpec = g_TaskResumeSpec(taskId)
    
    If IsArray(resumeSpec) Then
        For i = LBound(resumeSpec) To UBound(resumeSpec)
            Dim param As Variant
            param = resumeSpec(i)
            
            ' å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œå°è¯•è§£æä¸ºå•å…ƒæ ¼å¼•ç”¨
            If VarType(param) = vbString Then
                On Error Resume Next
                Dim rng As Range
                Set rng = Range(param)
                If Not rng Is Nothing Then
                    PushRangeValueToThread coThread, rng
                Else
                    PushValueToThread coThread, param
                End If
                On Error GoTo ErrorHandler
            Else
                If TypeName(param) = "Range" Then
                    PushRangeValueToThread coThread, param
                Else
                    PushValueToThread coThread, param
                End If
            End If
        Next i
    End If
    
    ' Resume
    Dim nargs As Long
    nargs = 0
    If IsArray(resumeSpec) Then
        nargs = UBound(resumeSpec) - LBound(resumeSpec) + 1
    End If
    
    Dim nres As LongPtr
    Dim result As Long
    result = lua_resume(coThread, g_LuaState.L, nargs, VarPtr(nres))
    
    ' å¤„ç†ç»“æœ
    HandleCoroutineResult taskId, result, CLng(nres)
    
    Exit Sub

ErrorHandler:
    g_TaskStatus(taskId) = "error"
    g_TaskError(taskId) = "Resumeé”™è¯¯: " & Err.Description
End Sub

' å¤„ç†åç¨‹è¿”å›ç»“æœ
Private Sub HandleCoroutineResult(taskId As String, result As Long, nres As Long)
    On Error GoTo ErrorHandler
    
    Dim coThread As LongPtr
    coThread = g_TaskCoThread(taskId)
    
    Select Case result
        Case LUA_OK  ' åç¨‹å®Œæˆ
            g_TaskStatus(taskId) = "done"
            g_TaskProgress(taskId) = 100
            
            If nres > 0 Then
                ' è·å–è¿”å›å€¼ï¼ˆå­—å…¸ï¼‰
                Dim retDict As Variant
                retDict = GetValue(coThread, -1)
                
                If IsArray(retDict) Then
                    ' è§£æè¿”å›å­—å…¸
                    ParseYieldReturn taskId, retDict, True
                Else
                    g_TaskValue(taskId) = retDict
                End If
                
                ' å†™å…¥æœ€ç»ˆç›®æ ‡
                WriteFinalResult taskId
            End If
            
        Case LUA_YIELD  ' åç¨‹ yield
            If nres > 0 Then
                ' è·å– yield å€¼ï¼ˆå­—å…¸ï¼‰
                Dim yieldDict As Variant
                yieldDict = GetValue(coThread, -1)
                
                If IsArray(yieldDict) Then
                    ' è§£æ yield å­—å…¸
                    ParseYieldReturn taskId, yieldDict, False
                    
                    ' å†™å…¥ä¸­é—´ç»“æœ
                    WriteIntermediateResult taskId
                End If
            End If
            
            g_TaskStatus(taskId) = "yielded"
            
        Case Else  ' é”™è¯¯
            g_TaskStatus(taskId) = "error"
            If nres > 0 Then
                g_TaskError(taskId) = GetStringFromState(coThread, -1)
            Else
                g_TaskError(taskId) = "åç¨‹é”™è¯¯: ä»£ç  " & result
            End If
    End Select
    
    Exit Sub

ErrorHandler:
    g_TaskStatus(taskId) = "error"
    g_TaskError(taskId) = "å¤„ç†ç»“æœé”™è¯¯: " & Err.Description
End Sub

' è§£æ yield/return å­—å…¸
Private Sub ParseYieldReturn(taskId As String, dict As Variant, isFinal As Boolean)
    On Error Resume Next
    
    ' dict æ˜¯äºŒç»´æ•°ç»„ï¼Œç¬¬ä¸€ç»´æ˜¯è¡Œï¼ˆé”®å€¼å¯¹ï¼‰ï¼Œç¬¬äºŒç»´æ˜¯åˆ—ï¼ˆkey, valueï¼‰
    If Not IsArray(dict) Then Exit Sub
    
    Dim i As Long
    For i = LBound(dict, 1) To UBound(dict, 1)
        Dim key As String
        Dim value As Variant
        
        key = dict(i, 1)
        value = dict(i, 2)
        
        Select Case LCase(key)
            Case "status"
                If Not isFinal Then g_TaskStatus(taskId) = CStr(value)
            Case "progress"
                g_TaskProgress(taskId) = CDbl(value)
            Case "message"
                g_TaskMessage(taskId) = value
            Case "value"
                g_TaskValue(taskId) = value
            Case "write"
                ' åŠ¨æ€å†™å…¥ç›®æ ‡ä¼šåœ¨å†™å…¥å‡½æ•°ä¸­å¤„ç†
        End Select
    Next i
End Sub

' å†™å…¥ä¸­é—´ç»“æœ
Private Sub WriteIntermediateResult(taskId As String)
    On Error GoTo ErrorHandler
    
    ' è·å–å†™å…¥ç›®æ ‡
    Dim writeTarget As String
    writeTarget = ""
    
    Dim value As Variant
    value = g_TaskValue(taskId)
    
    ' ä¼˜å…ˆä½¿ç”¨ yield å­—å…¸ä¸­çš„ write
    If IsArray(value) Then
        Dim i As Long
        For i = LBound(value, 1) To UBound(value, 1)
            If LCase(value(i, 1)) = "write" Then
                writeTarget = CStr(value(i, 2))
                Exit For
            End If
        Next i
    End If
    
    ' å…¶æ¬¡ä½¿ç”¨ ">>" åŠ¨æ€ç›®æ ‡
    If writeTarget = "" Then
        Dim dynamicTargets As Variant
        dynamicTargets = g_TaskDynamicTargets(taskId)
        If IsArray(dynamicTargets) Then
            If UBound(dynamicTargets) >= LBound(dynamicTargets) Then
                writeTarget = CStr(dynamicTargets(LBound(dynamicTargets)))
            End If
        End If
    End If
    
    ' å†™å…¥
    If writeTarget <> "" Then
        WriteToExcel writeTarget, value
    End If
    
    Exit Sub

ErrorHandler:
    ' å†™å…¥å¤±è´¥ä¸å½±å“åç¨‹ç»§ç»­
End Sub

' å†™å…¥æœ€ç»ˆç»“æœ
Private Sub WriteFinalResult(taskId As String)
    On Error GoTo ErrorHandler
    
    ' è·å–å†™å…¥ç›®æ ‡
    Dim writeTarget As String
    writeTarget = ""
    
    Dim value As Variant
    value = g_TaskValue(taskId)
    
    ' ä¼˜å…ˆä½¿ç”¨ return å­—å…¸ä¸­çš„ write
    If IsArray(value) Then
        Dim i As Long
        For i = LBound(value, 1) To UBound(value, 1)
            If LCase(value(i, 1)) = "write" Then
                writeTarget = CStr(value(i, 2))
                Exit For
            End If
        Next i
    End If
    
    ' å…¶æ¬¡ä½¿ç”¨ "->" æœ€ç»ˆç›®æ ‡
    If writeTarget = "" Then
        Dim writeTargets As Variant
        writeTargets = g_TaskWriteTargets(taskId)
        If IsArray(writeTargets) Then
            If UBound(writeTargets) >= LBound(writeTargets) Then
                writeTarget = CStr(writeTargets(LBound(writeTargets)))
            End If
        End If
    End If
    
    ' å†™å…¥
    If writeTarget <> "" Then
        WriteToExcel writeTarget, value
    End If
    
    Exit Sub

ErrorHandler:
    ' å†™å…¥å¤±è´¥ä¸å½±å“ä»»åŠ¡å®ŒæˆçŠ¶æ€
End Sub

' é€šç”¨å†™å…¥å‡½æ•°
Private Sub WriteToExcel(target As String, value As Variant)
    On Error Resume Next
    
    Dim rng As Range
    Set rng = Range(target)
    
    If rng Is Nothing Then Exit Sub
    
    ' æå–å®é™… valueï¼ˆå¦‚æœæ˜¯å­—å…¸ï¼‰
    Dim actualValue As Variant
    actualValue = value
    
    If IsArray(value) Then
        ' æ£€æŸ¥æ˜¯å¦æ˜¯å­—å…¸æ ¼å¼
        Dim i As Long
        For i = LBound(value, 1) To UBound(value, 1)
            If LCase(value(i, 1)) = "value" Then
                actualValue = value(i, 2)
                Exit For
            End If
        Next i
    End If
    
    ' å†™å…¥
    If IsArray(actualValue) Then
        ' æ•°ç»„å†™å…¥ï¼Œè‡ªåŠ¨æ‰©å±•
        Dim rows As Long, cols As Long
        rows = UBound(actualValue, 1) - LBound(actualValue, 1) + 1
        cols = UBound(actualValue, 2) - LBound(actualValue, 2) + 1
        
        rng.Resize(rows, cols).value = actualValue
    Else
        ' å•å€¼å†™å…¥
        rng.value = actualValue
    End If
End Sub


' ============================================
' ç¬¬å…­éƒ¨åˆ†ï¼šè¾…åŠ©å‡½æ•°ï¼ˆå†…éƒ¨ä½¿ç”¨ï¼‰
' ============================================

' ä» Lua æ ˆè·å–å­—ç¬¦ä¸²
Private Function GetStringFromState(ByVal L As LongPtr, ByVal idx As Long) As String
    Dim ptr As LongPtr
    Dim length As Long
    Dim buffer() As Byte
    
    ptr = lua_tolstring(L, idx, VarPtr(length))
    If ptr = 0 Then
        GetStringFromState = ""
        Exit Function
    End If
    
    If length > 0 Then
        ReDim buffer(0 To length - 1)
        CopyMemory buffer(0), ByVal ptr, length
        GetStringFromState = StrConv(buffer, vbUnicode)
    Else
        GetStringFromState = ""
    End If
End Function

' æ¨å…¥å•ä¸ªå€¼åˆ°ä¸» Lua æ ˆ
Private Sub PushValue(ByVal L As LongPtr, ByVal value As Variant)
    If IsEmpty(value) Or IsNull(value) Then
        lua_pushnil L
    ElseIf IsNumeric(value) Then
        lua_pushnumber L, CDbl(value)
    ElseIf VarType(value) = vbBoolean Then
        lua_pushboolean L, IIf(value, 1, 0)
    ElseIf IsArray(value) Then
        PushArray L, value
    Else
        lua_pushstring L, CStr(value)
    End If
End Sub

' æ¨å…¥å•ä¸ªå€¼åˆ°åç¨‹çº¿ç¨‹
Private Sub PushValueToThread(ByVal coThread As LongPtr, ByVal value As Variant)
    If IsEmpty(value) Or IsNull(value) Then
        lua_pushnil coThread
    ElseIf IsNumeric(value) Then
        lua_pushnumber coThread, CDbl(value)
    ElseIf VarType(value) = vbBoolean Then
        lua_pushboolean coThread, IIf(value, 1, 0)
    ElseIf IsArray(value) Then
        PushArrayToThread coThread, value
    Else
        lua_pushstring coThread, CStr(value)
    End If
End Sub

' æ¨å…¥ Range å¯¹è±¡åˆ°ä¸»æ ˆ
Private Sub PushRangeValue(ByVal L As LongPtr, ByVal rng As Range)
    If rng.Cells.Count = 1 Then
        PushValue L, rng.value
    Else
        Dim arr As Variant
        arr = rng.value
        PushArray L, arr
    End If
End Sub

' æ¨å…¥ Range å¯¹è±¡åˆ°åç¨‹çº¿ç¨‹
Private Sub PushRangeValueToThread(ByVal coThread As LongPtr, ByVal rng As Range)
    If rng.Cells.Count = 1 Then
        PushValueToThread coThread, rng.value
    Else
        Dim arr As Variant
        arr = rng.value
        PushArrayToThread coThread, arr
    End If
End Sub

' æ¨å…¥äºŒç»´æ•°ç»„ä¸º Lua tableï¼ˆä¸»æ ˆï¼‰
Private Sub PushArray(ByVal L As LongPtr, arr As Variant)
    Dim i As Long, j As Long
    Dim rows As Long, cols As Long
    
    rows = UBound(arr, 1) - LBound(arr, 1) + 1
    cols = UBound(arr, 2) - LBound(arr, 2) + 1
    
    ' åˆ›å»ºä¸»è¡¨
    lua_createtable L, rows, 0
    
    For i = LBound(arr, 1) To UBound(arr, 1)
        ' åˆ›å»ºè¡Œè¡¨
        lua_createtable L, cols, 0
        
        For j = LBound(arr, 2) To UBound(arr, 2)
            PushValue L, arr(i, j)
            lua_rawseti L, -2, j - LBound(arr, 2) + 1
        Next j
        
        lua_rawseti L, -2, i - LBound(arr, 1) + 1
    Next i
End Sub

' æ¨å…¥äºŒç»´æ•°ç»„ä¸º Lua tableï¼ˆåç¨‹çº¿ç¨‹ï¼‰
Private Sub PushArrayToThread(ByVal coThread As LongPtr, arr As Variant)
    Dim i As Long, j As Long
    Dim rows As Long, cols As Long
    
    rows = UBound(arr, 1) - LBound(arr, 1) + 1
    cols = UBound(arr, 2) - LBound(arr, 2) + 1
    
    ' åˆ›å»ºä¸»è¡¨
    lua_createtable coThread, rows, 0
    
    For i = LBound(arr, 1) To UBound(arr, 1)
        ' åˆ›å»ºè¡Œè¡¨
        lua_createtable coThread, cols, 0
        
        For j = LBound(arr, 2) To UBound(arr, 2)
            PushValueToThread coThread, arr(i, j)
            lua_rawseti coThread, -2, j - LBound(arr, 2) + 1
        Next j
        
        lua_rawseti coThread, -2, i - LBound(arr, 1) + 1
    Next i
End Sub

' ä» Lua æ ˆè·å–å€¼
Private Function GetValue(ByVal L As LongPtr, ByVal idx As Long) As Variant
    Dim luaType As Long
    luaType = lua_type(L, idx)
    
    Select Case luaType
        Case LUA_TNIL
            GetValue = Empty
        Case LUA_TBOOLEAN
            GetValue = (lua_toboolean(L, idx) <> 0)
        Case LUA_TNUMBER
            GetValue = lua_tonumberx(L, idx, 0)
        Case LUA_TSTRING
            GetValue = GetStringFromState(L, idx)
        Case LUA_TTABLE
            GetValue = TableToArray(L, idx)
        Case Else
            GetValue = "#LUA_TYPE_" & luaType
    End Select
End Function

' å°† Lua table è½¬æ¢ä¸ºäºŒç»´æ•°ç»„
Private Function TableToArray(ByVal L As LongPtr, ByVal idx As Long) As Variant
    Dim rows As LongPtr, cols As LongPtr
    Dim i As Long, j As Long
    Dim arr() As Variant
    Dim isArray As Boolean
    
    rows = lua_rawlen(L, idx)
    
    If rows = 0 Then
        TableToArray = Empty
        Exit Function
    End If
    
    ' æ£€æŸ¥ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦æ˜¯è¡¨
    lua_rawgeti L, idx, 1
    isArray = (lua_type(L, -1) = LUA_TTABLE)
    
    If isArray Then
        ' äºŒç»´æ•°ç»„
        cols = lua_rawlen(L, -1)
        lua_settop L, -2
        
        ReDim arr(1 To CLng(rows), 1 To CLng(cols))
        
        For i = 1 To CLng(rows)
            lua_rawgeti L, idx, CLng(i)
            For j = 1 To CLng(cols)
                lua_rawgeti L, -1, CLng(j)
                arr(i, j) = GetValue(L, -1)
                lua_settop L, -2
            Next j
            lua_settop L, -2
        Next i
    Else
        ' ä¸€ç»´æ•°ç»„ï¼ˆè½¬ä¸ºå•è¡ŒäºŒç»´æ•°ç»„ï¼‰
        lua_settop L, -2
        ReDim arr(1 To 1, 1 To CLng(rows))
        
        For i = 1 To CLng(rows)
            lua_rawgeti L, idx, CLng(i)
            arr(1, i) = GetValue(L, -1)
            lua_settop L, -2
        Next i
    End If
    
    TableToArray = arr
End Function

' æ ¹æ®è°ƒç”¨å•å…ƒæ ¼åœ°å€æŸ¥æ‰¾å·²å­˜åœ¨çš„ä»»åŠ¡
Private Function FindTaskByCell(taskCell As String) As String
    Dim tid As Variant
    If g_TaskCell Is Nothing Then Exit Function

    For Each tid In g_TaskCell.Keys
        If g_TaskCell(tid) = taskCell Then
            FindTaskByCell = CStr(tid)
            Exit Function
        End If
    Next

    FindTaskByCell = ""
End Function

' æ ¹æ®å•å…ƒæ ¼åœ°å€è·å–ä»»åŠ¡ID
Private Function GetTaskIdFromSelection() As String
    Dim cellAddr As String
    cellAddr = Selection.Address(External:=True)
    GetTaskIdFromSelection = FindTaskByCell(cellAddr)
End Function

Public Sub EnableLuaTaskMenu()
    On Error Resume Next

    ' åˆ é™¤å·²æœ‰èœå•ï¼Œé¿å…é‡å¤
    Call DisableLuaTaskMenu

    ' è·å–å³é”®èœå•ï¼ˆCellï¼‰
    Dim cMenu As CommandBar
    Set cMenu = Application.CommandBars("Cell")

    ' æ·»åŠ ä¸»èœå•
    Dim luaMenu As CommandBarControl
    Set luaMenu = cMenu.Controls.Add(Type:=msoControlPopup, Temporary:=True)
    luaMenu.Caption = "Lua ä»»åŠ¡ç®¡ç†"
    luaMenu.Tag = "LuaTaskMenu"

    ' æ·»åŠ å­èœå•
    AddLuaMenuItem luaMenu, "å¯åŠ¨ä»»åŠ¡", "LuaMenu_StartTask"
    AddLuaMenuItem luaMenu, "æŒ‚èµ·ä»»åŠ¡", "LuaMenu_PauseTask"
    AddLuaMenuItem luaMenu, "æ¢å¤ä»»åŠ¡", "LuaMenu_ResumeTask"
    AddLuaMenuItem luaMenu, "ç»ˆæ­¢ä»»åŠ¡", "LuaMenu_TerminateTask"
    AddLuaMenuItem luaMenu, "æŸ¥çœ‹ä»»åŠ¡è¯¦æƒ…", "LuaMenu_ShowDetail"

    MsgBox "Lua ä»»åŠ¡å³é”®èœå•å·²å¯ç”¨ã€‚", vbInformation
End Sub

' è¾…åŠ©ï¼šå¢åŠ å­èœå•é¡¹
Private Sub AddLuaMenuItem(parent As CommandBarControl, caption As String, onAction As String)
    Dim ctrl As CommandBarControl
    Set ctrl = parent.Controls.Add(Type:=msoControlButton, Temporary:=True)
    ctrl.Caption = caption
    ctrl.OnAction = onAction
End Sub

Public Sub DisableLuaTaskMenu()
    On Error Resume Next
    Dim cMenu As CommandBar
    Set cMenu = Application.CommandBars("Cell")

    Dim ctrl As CommandBarControl
    For Each ctrl In cMenu.Controls
        If ctrl.Tag = "LuaTaskMenu" Then ctrl.Delete
    Next
End Sub

' ===== å¯åŠ¨ä»»åŠ¡ =====
Public Sub LuaMenu_StartTask()
    Dim taskId As String
    taskId = GetTaskIdFromSelection()
    If taskId = "" Then
        MsgBox "å½“å‰å•å…ƒæ ¼æ²¡æœ‰ Lua ä»»åŠ¡ã€‚", vbExclamation
        Exit Sub
    End If
    If g_TaskStatus(taskId) = "defined" Then
        StartLuaCoroutine taskId
        MsgBox "ä»»åŠ¡å·²å¯åŠ¨: " & taskId, vbInformation
    Else
        MsgBox "ä»»åŠ¡çŠ¶æ€ä¸º " & g_TaskStatus(taskId) & "ï¼Œæ— æ³•å¯åŠ¨ã€‚", vbExclamation
    End If
End Sub

' ===== æŒ‚èµ·ä»»åŠ¡ =====
Public Sub LuaMenu_PauseTask()
    Dim taskId As String
    taskId = GetTaskIdFromSelection()
    If taskId = "" Then MsgBox "æ— ä»»åŠ¡å¯æŒ‚èµ·", vbExclamation: Exit Sub
    PauseTask taskId
End Sub

' ===== æ¢å¤ä»»åŠ¡ =====
Public Sub LuaMenu_ResumeTask()
    Dim taskId As String
    taskId = GetTaskIdFromSelection()
    If taskId = "" Then MsgBox "æ— ä»»åŠ¡å¯æ¢å¤", vbExclamation: Exit Sub
    ResumeTask taskId
End Sub

' ===== ç»ˆæ­¢ä»»åŠ¡ =====
Public Sub LuaMenu_TerminateTask()
    Dim taskId As String
    taskId = GetTaskIdFromSelection()
    If taskId = "" Then MsgBox "æ— ä»»åŠ¡å¯ç»ˆæ­¢", vbExclamation: Exit Sub
    TerminateAndDeleteTask taskId
End Sub

' ===== æŸ¥çœ‹ä»»åŠ¡è¯¦æƒ… =====
Public Sub LuaMenu_ShowDetail()
    Dim taskId As String
    taskId = GetTaskIdFromSelection()
    If taskId = "" Then MsgBox "æ— ä»»åŠ¡å¯æŸ¥çœ‹", vbExclamation: Exit Sub
    ShowTaskDetail taskId
End Sub
