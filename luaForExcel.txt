' ============================================
' Excel-Lua 5.4 集成模块（完整版 + 协程支持）
' 使用纯 DLL 调用方式
' ============================================

Option Explicit

' ===== Lua 5.4 DLL 声明 =====
#If VBA7 Then
    ' 基础 API
    Private Declare PtrSafe Function luaL_newstate Lib "lua54.dll" () As LongPtr
    Private Declare PtrSafe Sub luaL_openlibs Lib "lua54.dll" (ByVal L As LongPtr)
    Private Declare PtrSafe Sub lua_close Lib "lua54.dll" (ByVal L As LongPtr)
    Private Declare PtrSafe Function luaL_loadstring Lib "lua54.dll" (ByVal L As LongPtr, ByVal s As String) As Long
    Private Declare PtrSafe Function lua_pcallk Lib "lua54.dll" (ByVal L As LongPtr, ByVal nargs As Long, ByVal nResults As Long, ByVal msgh As Long, ByVal ctx As LongPtr, ByVal k As LongPtr) As Long
    Private Declare PtrSafe Function lua_tonumberx Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal isnum As LongPtr) As Double
    Private Declare PtrSafe Function lua_tolstring Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal leng As LongPtr) As LongPtr
    Private Declare PtrSafe Function lua_toboolean Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long) As Long
    Private Declare PtrSafe Function lua_type Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long) As Long
    Private Declare PtrSafe Sub lua_pushnil Lib "lua54.dll" (ByVal L As LongPtr)
    Private Declare PtrSafe Sub lua_pushnumber Lib "lua54.dll" (ByVal L As LongPtr, ByVal n As Double)
    Private Declare PtrSafe Sub lua_pushstring Lib "lua54.dll" (ByVal L As LongPtr, ByVal s As String)
    Private Declare PtrSafe Sub lua_pushboolean Lib "lua54.dll" (ByVal L As LongPtr, ByVal b As Long)
    Private Declare PtrSafe Function lua_gettop Lib "lua54.dll" (ByVal L As LongPtr) As Long
    Private Declare PtrSafe Sub lua_settop Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long)
    Private Declare PtrSafe Function lua_getglobal Lib "lua54.dll" (ByVal L As LongPtr, ByVal name As String) As Long
    Private Declare PtrSafe Sub lua_createtable Lib "lua54.dll" (ByVal L As LongPtr, ByVal narr As Long, ByVal nrec As Long)
    Private Declare PtrSafe Sub lua_rawseti Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal n As LongPtr)
    Private Declare PtrSafe Function lua_rawgeti Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal n As LongPtr) As Long
    Private Declare PtrSafe Function lua_rawlen Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long) As LongPtr
    Private Declare PtrSafe Function luaL_loadfilex Lib "lua54.dll" (ByVal L As LongPtr, ByVal filename As String, ByVal mode As LongPtr) As Long
    Private Declare PtrSafe Sub lua_setglobal Lib "lua54.dll" (ByVal L As LongPtr, ByVal name As String)
    Private Declare PtrSafe Function lua_next Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long) As Long
    Private Declare PtrSafe Sub lua_pushvalue Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long)
    Private Declare PtrSafe Function lua_getfield Lib "lua54.dll" (ByVal L As LongPtr, ByVal idx As Long, ByVal k As String) As Long

    ' 协程 API
    Private Declare PtrSafe Function lua_newthread Lib "lua54.dll" (ByVal L As LongPtr) As LongPtr
    Private Declare PtrSafe Function lua_resume Lib "lua54.dll" (ByVal L As LongPtr, ByVal from As LongPtr, ByVal narg As Long, ByVal nres As LongPtr) As Long
    Private Declare PtrSafe Function lua_status Lib "lua54.dll" (ByVal L As LongPtr) As Long
    Private Declare PtrSafe Sub lua_xmove Lib "lua54.dll" (ByVal fromL As LongPtr, ByVal toL As LongPtr, ByVal n As Long)

    ' 调度器辅助状态
    Private g_SchedulerCursor As Long   ' Round-Robin 游标
    Private g_StateDirty As Boolean     ' 本 tick 是否有状态变化，用来检测是否需要刷新单元格

    ' 系统 API
    Private Declare PtrSafe Sub CopyMemory Lib "kernel32" Alias "RtlMoveMemory" (Destination As Any, Source As Any, ByVal length As LongPtr)
    Private Declare PtrSafe Function lstrlenA Lib "kernel32" (ByVal ptr As LongPtr) As Long
    
    Private Type LuaState
        L As LongPtr
        functionsPath As String
        lastModified As Date
    End Type
    
    ' 协程任务状态 - 不使用 Type，改用多个 Dictionary
    ' 每个 Dictionary 的 key 都是 taskId
#Else
    ' 32位版本声明（暂不提供）
#End If

' ===== Lua 类型常量 =====
Private Const LUA_TNIL = 0
Private Const LUA_TBOOLEAN = 1
Private Const LUA_TNUMBER = 3
Private Const LUA_TSTRING = 4
Private Const LUA_TTABLE = 5
Private Const LUA_TFUNCTION = 6

' ===== Lua 状态常量 =====
Private Const LUA_OK = 0
Private Const LUA_YIELD = 1
Private Const LUA_ERRRUN = 2

' ===== 全局变量 =====
Private g_LuaState As LuaState
Private g_Initialized As Boolean
Private g_HotReloadEnabled As Boolean

' ===== 协程全局变量 =====
Private g_TaskFunc As Object           ' taskId -> func name
Private g_TaskStartArgs As Object      ' taskId -> startArgs array
Private g_TaskResumeSpec As Object     ' taskId -> resumeSpec array
Private g_TaskCell As Object           ' taskId -> taskCell address
Private g_TaskStatus As Object         ' taskId -> status string:defined、yield、done、error
Private g_TaskProgress As Object       ' taskId -> progress number
Private g_TaskMessage As Object        ' taskId -> message variant
Private g_TaskValue As Object          ' taskId -> value variant
Private g_TaskError As Object          ' taskId -> error message
Private g_TaskCoThread As Object       ' taskId -> coThread LongPtr
Private g_TaskQueue As Object          ' taskId -> True (active tasks)
Private g_SchedulerRunning As Boolean
Private g_NextTaskId As Long
Private g_SchedulerIntervalSec As Long
Private g_MaxIterationsPerTick As Long   ' 每次调度迭代次数
' ===== 配置常量 =====
Private Const DEFAULT_HOT_RELOAD_ENABLED As Boolean = True
Private Const SCHEDULER_INTERVAL_SEC As Double = 1  ' 调度间隔，默认1
Private Const DEFAULT_MAX_ITERATIONS_PER_TICK As Long = 1  ' 每次调度迭代次数，默认1

' ============================================
' 第一部分：核心初始化和清理
' ============================================

' 主初始化函数：创建空白 Lua 状态机
Private Function InitLuaState() As Boolean
    On Error GoTo ErrorHandler
    
    ' 如果已初始化，直接返回成功
    If g_Initialized Then
        InitLuaState = True
        Exit Function
    End If
    
    ' 创建新的 Lua 状态机
    g_LuaState.L = luaL_newstate()
    If g_LuaState.L = 0 Then
        MsgBox "无法创建 Lua 状态机。" & vbCrLf & _
               "请确保 lua54.dll 在系统路径中。", vbCritical, "初始化失败"
        InitLuaState = False
        Exit Function
    End If
    
    ' 加载 Lua 标准库
    luaL_openlibs g_LuaState.L
    
    ' 设置 functions.lua 路径
    g_LuaState.functionsPath = ThisWorkbook.Path & "\functions.lua"
    g_LuaState.lastModified = #1/1/1900#
    
    ' 标记为已初始化
    g_Initialized = True
    g_HotReloadEnabled = DEFAULT_HOT_RELOAD_ENABLED
    
    ' 初始化协程系统
    InitCoroutineSystem
    
    ' 尝试首次加载 functions.lua（失败不影响继续）
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    If fso.FileExists(g_LuaState.functionsPath) Then
        If TryLoadFunctionsFile() Then
            ' 加载成功，静默处理
        Else
            MsgBox "functions.lua 加载失败。" & vbCrLf & _
                   "Lua 引擎已启动，但自定义函数不可用。" & vbCrLf & _
                   "请检查文件语法后手动重载。", vbExclamation, "初始化警告"
        End If
    End If
    
    InitLuaState = True
    Exit Function

ErrorHandler:
    MsgBox "初始化 Lua 失败: " & Err.Description, vbCritical, "严重错误"
    InitLuaState = False
End Function

' 初始化协程系统
Private Sub InitCoroutineSystem()
    g_MaxIterationsPerTick = DEFAULT_MAX_ITERATIONS_PER_TICK
    g_SchedulerIntervalSec = SCHEDULER_INTERVAL_SEC
    If g_TaskFunc Is Nothing Then
        Set g_TaskFunc = CreateObject("Scripting.Dictionary")
        Set g_TaskStartArgs = CreateObject("Scripting.Dictionary")
        Set g_TaskResumeSpec = CreateObject("Scripting.Dictionary")
        Set g_TaskCell = CreateObject("Scripting.Dictionary")
        Set g_TaskStatus = CreateObject("Scripting.Dictionary")
        Set g_TaskProgress = CreateObject("Scripting.Dictionary")
        Set g_TaskMessage = CreateObject("Scripting.Dictionary")
        Set g_TaskValue = CreateObject("Scripting.Dictionary")
        Set g_TaskError = CreateObject("Scripting.Dictionary")
        Set g_TaskCoThread = CreateObject("Scripting.Dictionary")
        Set g_TaskQueue = CreateObject("Scripting.Dictionary")
    End If
    
    g_NextTaskId = 1
    g_SchedulerCursor = 0
    g_StateDirty = False
End Sub

' 清理 Lua 状态机
Public Sub CleanupLua()
    If g_Initialized Then
        g_SchedulerRunning = False
        
        If Not g_TaskFunc Is Nothing Then
            g_TaskFunc.RemoveAll
            g_TaskStartArgs.RemoveAll
            g_TaskResumeSpec.RemoveAll
            g_TaskCell.RemoveAll
            g_TaskStatus.RemoveAll
            g_TaskProgress.RemoveAll
            g_TaskMessage.RemoveAll
            g_TaskValue.RemoveAll
            g_TaskError.RemoveAll
            g_TaskCoThread.RemoveAll
            g_TaskQueue.RemoveAll
        End If
        
        lua_close g_LuaState.L
        g_LuaState.L = 0
        g_Initialized = False
    End If
End Sub

' ============================================
' 第二部分：functions.lua 加载和热重载
' ============================================

' 在临时状态中验证 functions.lua 语法
Private Function ValidateFunctionsFile() As Boolean
    On Error GoTo ErrorHandler
    
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    If Not fso.FileExists(g_LuaState.functionsPath) Then
        ValidateFunctionsFile = False
        Exit Function
    End If
    
    ' 创建临时 Lua 状态
    Dim tempL As LongPtr
    tempL = luaL_newstate()
    If tempL = 0 Then
        ValidateFunctionsFile = False
        Exit Function
    End If
    
    luaL_openlibs tempL
    
    ' 尝试加载和执行
    Dim result As Long
    result = luaL_loadfilex(tempL, g_LuaState.functionsPath, 0)
    If result = 0 Then result = lua_pcallk(tempL, 0, 0, 0, 0, 0)
    
    ' 检查结果
    If result <> 0 Then
        Dim errMsg As String
        errMsg = GetStringFromState(tempL, -1)
        lua_close tempL
        
        MsgBox "functions.lua 存在语法错误：" & vbCrLf & vbCrLf & _
               errMsg, vbCritical, "文件验证失败"
        ValidateFunctionsFile = False
        Exit Function
    End If
    
    lua_close tempL
    ValidateFunctionsFile = True
    Exit Function

ErrorHandler:
    If tempL <> 0 Then lua_close tempL
    ValidateFunctionsFile = False
End Function

' 在主状态中加载 functions.lua
Private Function LoadFunctionsIntoMainState() As Boolean
    On Error GoTo ErrorHandler
    
    Dim topBefore As Long
    topBefore = lua_gettop(g_LuaState.L)
    
    Dim result As Long
    result = luaL_loadfilex(g_LuaState.L, g_LuaState.functionsPath, 0)
    If result = 0 Then result = lua_pcallk(g_LuaState.L, 0, 0, 0, 0, 0)
    
    ' 恢复栈
    lua_settop g_LuaState.L, topBefore
    
    If result <> 0 Then
        Dim errMsg As String
        errMsg = GetStringFromState(g_LuaState.L, -1)
        lua_settop g_LuaState.L, topBefore
        
        MsgBox "主状态加载 functions.lua 失败：" & vbCrLf & vbCrLf & _
               errMsg, vbCritical, "加载失败"
        LoadFunctionsIntoMainState = False
        Exit Function
    End If
    
    ' 更新时间戳
    g_LuaState.lastModified = FileDateTime(g_LuaState.functionsPath)
    LoadFunctionsIntoMainState = True
    Exit Function

ErrorHandler:
    MsgBox "加载过程发生 VBA 错误: " & Err.Description, vbCritical, "严重错误"
    LoadFunctionsIntoMainState = False
End Function

' 尝试加载 functions.lua（先验证，再加载）
Private Function TryLoadFunctionsFile() As Boolean
    ' 第一步：验证语法
    If Not ValidateFunctionsFile() Then
        TryLoadFunctionsFile = False
        Exit Function
    End If
    
    ' 第二步：加载到主状态
    TryLoadFunctionsFile = LoadFunctionsIntoMainState()
End Function

' 检查文件是否需要重载
Private Function NeedsReload() As Boolean
    Dim fso As Object
    Set fso = CreateObject("Scripting.FileSystemObject")
    
    ' 文件不存在，无需重载
    If Not fso.FileExists(g_LuaState.functionsPath) Then
        NeedsReload = False
        Exit Function
    End If
    
    ' 比较修改时间
    Dim currentModified As Date
    currentModified = FileDateTime(g_LuaState.functionsPath)
    NeedsReload = (currentModified <> g_LuaState.lastModified)
End Function

' 自动热重载检查（如果启用）
Private Sub CheckAutoReload()
    ' 未启用热重载，直接返回
    If Not g_HotReloadEnabled Then Exit Sub
    
    ' 不需要重载，直接返回
    If Not NeedsReload() Then Exit Sub
    
    ' 执行重载（失败也不影响继续使用旧状态）
    If TryLoadFunctionsFile() Then
        ' 成功，静默处理
    Else
        ' 失败时已有弹窗提示，这里不再处理
    End If
End Sub

' ============================================
' 第三部分：公共接口（基础功能）
' ============================================

' 执行 Lua 表达式
Public Function LuaEval(expression As String) As Variant
    On Error GoTo ErrorHandler
    
    ' 确保初始化
    If Not InitLuaState() Then
        LuaEval = CVErr(xlErrValue)
        Exit Function
    End If
    
    ' 检查热重载
    CheckAutoReload
    
    ' 构造代码
    Dim fullCode As String
    fullCode = "return " & expression
    
    ' 加载代码
    Dim result As Long
    result = luaL_loadstring(g_LuaState.L, fullCode)
    If result <> 0 Then
        LuaEval = "语法错误: " & GetStringFromState(g_LuaState.L, -1)
        lua_settop g_LuaState.L, 0
        Exit Function
    End If
    
    ' 执行代码
    result = lua_pcallk(g_LuaState.L, 0, 1, 0, 0, 0)
    If result <> 0 Then
        LuaEval = "运行错误: " & GetStringFromState(g_LuaState.L, -1)
        lua_settop g_LuaState.L, 0
        Exit Function
    End If
    
    ' 获取结果
    LuaEval = GetValue(g_LuaState.L, -1)
    lua_settop g_LuaState.L, 0
    Exit Function

ErrorHandler:
    LuaEval = "VBA错误: " & Err.Description
    If g_Initialized Then lua_settop g_LuaState.L, 0
End Function

' 调用 functions.lua 中的函数
Public Function LuaCall(funcName As String, ParamArray args() As Variant) As Variant
    On Error GoTo ErrorHandler
    
    ' 确保初始化
    If Not InitLuaState() Then
        LuaCall = CVErr(xlErrValue)
        Exit Function
    End If
    
    ' 检查热重载
    CheckAutoReload
    
    ' 获取函数
    lua_getglobal g_LuaState.L, funcName
    If lua_type(g_LuaState.L, -1) <> LUA_TFUNCTION Then
        lua_settop g_LuaState.L, 0
        LuaCall = "错误: 函数 '" & funcName & "' 不存在"
        Exit Function
    End If
    
    ' 推入参数
    Dim i As Long, argCount As Long
    argCount = 0
    For i = LBound(args) To UBound(args)
        PushValue g_LuaState.L, args(i)
        argCount = argCount + 1
    Next i
    
    ' 调用函数
    Dim result As Long
    result = lua_pcallk(g_LuaState.L, argCount, -1, 0, 0, 0)
    If result <> 0 Then
        LuaCall = "运行错误: " & GetStringFromState(g_LuaState.L, -1)
        lua_settop g_LuaState.L, 0
        Exit Function
    End If
    
    ' 处理返回值
    Dim nResults As Long
    nResults = lua_gettop(g_LuaState.L)
    
    If nResults = 0 Then
        LuaCall = Empty
    ElseIf nResults = 1 Then
        LuaCall = GetValue(g_LuaState.L, -1)
    Else
        ' 多个返回值
        Dim results() As Variant
        ReDim results(1 To 1, 1 To nResults)
        For i = 1 To nResults
            results(1, i) = GetValue(g_LuaState.L, i)
        Next i
        LuaCall = results
    End If
    
    lua_settop g_LuaState.L, 0
    Exit Function

ErrorHandler:
    LuaCall = "VBA错误: " & Err.Description
    If g_Initialized Then lua_settop g_LuaState.L, 0
End Function

' ============================================
' 第四部分：协程 UDF 接口
' ============================================

' 任务定义函数
Public Function LuaTask(ParamArray params() As Variant) As String
    On Error GoTo ErrorHandler

    If Not InitLuaState() Then
        LuaTask = "#ERROR: Lua未初始化"
        Exit Function
    End If

    If UBound(params) < 0 Then
        LuaTask = "#ERROR: 需要函数名"
        Exit Function
    End If

    Dim taskCell As String
    taskCell = Application.Caller.Address(External:=True)

    Dim existingTaskId As String
    existingTaskId = FindTaskByCell(taskCell)

    If existingTaskId <> "" Then
        LuaTask = existingTaskId
        Exit Function
    End If

    Dim funcName As String
    funcName = CStr(params(0))

    Dim startArgs As Variant, resumeSpec As Variant
    startArgs = Array()
    resumeSpec = Array()

    Dim phase As Long
    phase = 0

    Dim startList As Object, resumeList As Object
    Set startList = CreateObject("System.Collections.ArrayList")
    Set resumeList = CreateObject("System.Collections.ArrayList")

    Dim i As Long
    For i = 1 To UBound(params)
        If VarType(params(i)) = vbString Then
            If params(i) = "|" Then
                phase = 1
            Else
                Select Case phase
                    Case 0: startList.Add params(i)
                    Case 1: resumeList.Add params(i)
                End Select
            End If
        Else
            Select Case phase
                Case 0: startList.Add params(i)
                Case 1: resumeList.Add params(i)
            End Select
        End If
    Next i

    If startList.Count > 0 Then startArgs = startList.ToArray()
    If resumeList.Count > 0 Then resumeSpec = resumeList.ToArray()

    Dim taskId As String
    taskId = "TASK_" & g_NextTaskId
    g_NextTaskId = g_NextTaskId + 1

    g_TaskFunc(taskId) = funcName
    g_TaskStartArgs(taskId) = startArgs
    g_TaskResumeSpec(taskId) = resumeSpec
    g_TaskCell(taskId) = taskCell
    g_TaskStatus(taskId) = "defined"
    g_TaskProgress(taskId) = 0
    g_TaskMessage(taskId) = Empty
    g_TaskValue(taskId) = Empty
    g_TaskError(taskId) = ""
    g_TaskCoThread(taskId) = 0

    LuaTask = taskId
    Exit Function

ErrorHandler:
    LuaTask = "#ERROR: " & Err.Description
End Function

' 读取任务状态
Public Function LuaGet(taskId As String, field As String) As Variant
    On Error GoTo ErrorHandler
    
    ' 标记为 volatile，每次计算都会刷新
    Application.Volatile True
    
    If g_TaskFunc Is Nothing Then
        InitCoroutineSystem
    End If
    
    If Not g_TaskFunc.Exists(taskId) Then
        LuaGet = "#ERROR: 任务不存在"
        Exit Function
    End If
    
    Select Case LCase(field)
        Case "status"
            LuaGet = g_TaskStatus(taskId)
        Case "progress"
            LuaGet = g_TaskProgress(taskId)
        Case "message"
            LuaGet = g_TaskMessage(taskId)
        Case "value"
            LuaGet = g_TaskValue(taskId)
        Case "error"
            LuaGet = g_TaskError(taskId)
        Case "summary"
            Dim summary As String
            summary = "状态:" & g_TaskStatus(taskId)
            summary = summary & " | 进度:" & Format(g_TaskProgress(taskId), "0.0") & "%"
            If g_TaskStatus(taskId) = "error" Then
                summary = summary & " | 错误:" & Left(g_TaskError(taskId), 30)
            End If
            LuaGet = summary
        Case Else
            LuaGet = "#ERROR: 未知字段"
    End Select
    
    Exit Function

ErrorHandler:
    LuaGet = "#ERROR: " & Err.Description
End Function

' ============================================
' 第五部分：协程执行和调度
' ============================================

' 启动协程
Public Sub StartLuaCoroutine(taskId As String)
    On Error GoTo ErrorHandler
    
    If g_TaskFunc Is Nothing Then
        InitCoroutineSystem
    End If
    
    If Not g_TaskFunc.Exists(taskId) Then
        MsgBox "错误：任务 " & taskId & " 不存在", vbCritical
        Exit Sub
    End If
    
    If g_TaskStatus(taskId) <> "defined" Then
        MsgBox "错误：任务已启动或已完成", vbExclamation
        Exit Sub
    End If
    
    ' 创建协程线程
    Dim coThread As LongPtr
    coThread = lua_newthread(g_LuaState.L)
    If coThread = 0 Then
        g_TaskStatus(taskId) = "error"
        g_TaskError(taskId) = "无法创建协程线程"
        Exit Sub
    End If
    
    g_TaskCoThread(taskId) = coThread
    
    ' 获取协程函数
    lua_getglobal g_LuaState.L, g_TaskFunc(taskId)
    
    ' 移动函数到协程线程
    lua_xmove g_LuaState.L, coThread, 1
    
    ' 推入 taskCell 作为第一个参数
    lua_pushstring coThread, g_TaskCell(taskId)
    
    ' 推入启动参数
    Dim i As Long
    Dim startArgs As Variant
    startArgs = g_TaskStartArgs(taskId)
    
    If IsArray(startArgs) Then
        For i = LBound(startArgs) To UBound(startArgs)
            PushValue coThread, startArgs(i)  ' 或 PushValueToThread coThread, startArgs(i)
        Next i
    End If
    
    ' 首次 resume
    Dim nargs As Long
    nargs = 1  ' taskCell
    If IsArray(startArgs) Then
        nargs = nargs + UBound(startArgs) - LBound(startArgs) + 1
    End If
    
    Dim nres As LongPtr
    Dim result As Long
    result = lua_resume(coThread, g_LuaState.L, nargs, VarPtr(nres))
    
    ' 处理结果
    HandleCoroutineResult taskId, result, CLng(nres)
    
    ' 加入调度队列
    If g_TaskStatus(taskId) = "yielded" Then
        g_TaskQueue(taskId) = True
        StartSchedulerIfNeeded
    End If
    
    Exit Sub

ErrorHandler:
    If g_TaskFunc.Exists(taskId) Then
        g_TaskStatus(taskId) = "error"
        g_TaskError(taskId) = "VBA错误: " & Err.Description
    End If
    MsgBox "启动协程失败: " & Err.Description, vbCritical
End Sub

' 启动调度器
Private Sub StartSchedulerIfNeeded()
    If g_SchedulerRunning Then Exit Sub
    If g_TaskQueue Is Nothing Then Exit Sub
    If g_TaskQueue.Count = 0 Then Exit Sub

    g_SchedulerRunning = True
    Application.OnTime _
        Now + TimeSerial(0, 0, g_SchedulerIntervalSec), _
        "SchedulerTick"
End Sub

' 调度器心跳
Public Sub SchedulerTick()
    On Error Resume Next
    
    ' 检查运行标志
    If Not g_SchedulerRunning Then
        Exit Sub
    End If
    
    If g_TaskQueue Is Nothing Or g_TaskQueue.Count = 0 Then
        g_SchedulerRunning = False
        Exit Sub
    End If

    Application.ScreenUpdating = False
    Application.EnableEvents = False
    Application.Calculation = xlCalculationManual

    ' ---- 复制当前任务列表（快照）----
    Dim taskIds() As Variant
    ReDim taskIds(0 To g_TaskQueue.Count - 1)

    Dim idx As Long
    Dim taskId As Variant
    idx = 0
    For Each taskId In g_TaskQueue.Keys
        taskIds(idx) = taskId
        idx = idx + 1
    Next

    Dim total As Long
    total = UBound(taskIds) + 1
    If total = 0 Then GoTo ExitTick

    ' ---- Round-Robin 调度 ----
    Dim executed As Long
    executed = 0

    Dim cur As Long
    cur = g_SchedulerCursor Mod total

    Dim tasksToRemove As Object
    Set tasksToRemove = CreateObject("System.Collections.ArrayList")

    Do While executed < g_MaxIterationsPerTick And executed < total
        taskId = taskIds(cur)

        If g_TaskFunc.Exists(CStr(taskId)) Then
            ResumeCoroutine CStr(taskId)
            executed = executed + 1

            If g_TaskStatus(CStr(taskId)) = "done" _
            Or g_TaskStatus(CStr(taskId)) = "error" Then
                tasksToRemove.Add taskId
            End If
        Else
            tasksToRemove.Add taskId
        End If

        cur = (cur + 1) Mod total
    Loop

    ' ---- 更新游标 ----
    g_SchedulerCursor = cur

    ' ---- 清理完成 / 错误任务 ----
    Dim i As Long
    For i = 0 To tasksToRemove.Count - 1
        If g_TaskQueue.Exists(tasksToRemove(i)) Then
            g_TaskQueue.Remove tasksToRemove(i)
        End If
    Next i

ExitTick:
    Application.Calculation = xlCalculationAutomatic
    Application.EnableEvents = True
    Application.ScreenUpdating = True

    ' 关键：一个 tick 只刷新一次
    If g_StateDirty Then
        g_StateDirty = False
        ActiveSheet.Calculate ' 只刷新活动单元表
        ' Application.Calculate '刷新整个工作簿

    End If

    ' 继续或停止调度
    If g_TaskQueue.Count > 0 Then
        Application.OnTime _
            Now + TimeSerial(0, 0, g_SchedulerIntervalSec), _
            "SchedulerTick"
    Else
        g_SchedulerRunning = False
    End If
End Sub

' Resume 协程
Private Sub ResumeCoroutine(taskId As String)
    On Error GoTo ErrorHandler
    
    If g_TaskStatus(taskId) <> "yielded" Then Exit Sub
    
    Dim coThread As LongPtr
    coThread = g_TaskCoThread(taskId)
    
    ' 清空协程栈
    lua_settop coThread, 0
    
    ' 推入 resume 参数
    Dim i As Long
    Dim resumeSpec As Variant
    resumeSpec = g_TaskResumeSpec(taskId)
    
    If IsArray(resumeSpec) Then
        For i = LBound(resumeSpec) To UBound(resumeSpec)
            Dim param As Variant
            param = resumeSpec(i)
            
            ' 如果是字符串，尝试解析为单元格引用
            If VarType(param) = vbString Then
                ' 尝试解析为单元格引用
                On Error Resume Next
                Dim rng As Range
                Set rng = Range(param)
                On Error GoTo ErrorHandler
                
                If Not rng Is Nothing Then
                    PushValue coThread, rng  ' 或 PushValueToThread
                Else
                    PushValue coThread, param  ' 或 PushValueToThread
                End If
            Else
                PushValue coThread, param  ' 或 PushValueToThread
            End If
        Next i
    End If
    
    ' Resume
    Dim nargs As Long
    nargs = 0
    If IsArray(resumeSpec) Then
        nargs = UBound(resumeSpec) - LBound(resumeSpec) + 1
    End If
    
    Dim nres As LongPtr
    Dim result As Long
    result = lua_resume(coThread, g_LuaState.L, nargs, VarPtr(nres))
    
    ' 处理结果
    HandleCoroutineResult taskId, result, CLng(nres)
    
    Exit Sub

ErrorHandler:
    g_TaskStatus(taskId) = "error"
    g_TaskError(taskId) = "Resume错误: " & Err.Description
End Sub

' 手动停止调度器
Public Sub StopScheduler()
    ' 停止调度标志
    g_SchedulerRunning = False
    
    ' 尝试取消所有 OnTime 调度
    On Error Resume Next
    Application.OnTime Now + TimeValue("00:00:01") * g_SchedulerIntervalSec, "SchedulerTick", , False
    
    MsgBox "调度器已停止。" & vbCrLf & _
           "活跃任务将保持在队列中，不会继续执行。" & vbCrLf & vbCrLf & _
           "使用 ResumeScheduler 重新启动。", vbInformation, "调度器已停止"
End Sub

' 恢复调度器
Public Sub ResumeScheduler()
    If g_TaskQueue Is Nothing Or g_TaskQueue.Count = 0 Then
        MsgBox "队列中没有任务，无需启动调度器。", vbExclamation, "无任务"
        Exit Sub
    End If
    
    If g_SchedulerRunning Then
        MsgBox "调度器已在运行中。", vbInformation, "调度器状态"
        Exit Sub
    End If
    
    g_SchedulerRunning = True
    Application.OnTime Now + TimeValue("00:00:01") * g_SchedulerIntervalSec, "SchedulerTick"
    
    MsgBox "调度器已启动。" & vbCrLf & _
           "当前队列任务数: " & g_TaskQueue.Count, vbInformation, "调度器已启动"
End Sub

' 处理协程返回结果
Private Sub HandleCoroutineResult(taskId As String, result As Long, nres As Long)
    On Error GoTo ErrorHandler
    
    Dim coThread As LongPtr
    coThread = g_TaskCoThread(taskId)
    
    Select Case result
        Case LUA_OK
            g_TaskStatus(taskId) = "done"
            g_StateDirty = True
            g_TaskProgress(taskId) = 100
            
            If nres > 0 Then
                Dim retDict As Variant
                retDict = GetValue(coThread, -1)
                
                If IsArray(retDict) Then
                    ParseYieldReturn taskId, retDict, True
                Else
                    g_TaskValue(taskId) = retDict
                End If
            End If
            
        Case LUA_YIELD
            If nres > 0 Then
                Dim yieldDict As Variant
                yieldDict = GetValue(coThread, -1)
                
                If IsArray(yieldDict) Then
                    ParseYieldReturn taskId, yieldDict, False
                End If
            End If
            
            g_TaskStatus(taskId) = "yielded"
            g_StateDirty = True

            
        Case Else
            g_TaskStatus(taskId) = "error"
            g_StateDirty = True

            If nres > 0 Then
                g_TaskError(taskId) = GetStringFromState(coThread, -1)
            Else
                g_TaskError(taskId) = "协程错误: 代码 " & result
            End If
    End Select
    
    Exit Sub

ErrorHandler:
    g_TaskStatus(taskId) = "error"
    g_TaskError(taskId) = "处理结果错误: " & Err.Description
End Sub

' 解析 yield/return 字典
Private Sub ParseYieldReturn(taskId As String, dict As Variant, isFinal As Boolean)
    On Error Resume Next
    
    ' dict 是二维数组，第一维是行（键值对），第二维是列（key, value）
    If Not IsArray(dict) Then Exit Sub
    
    Dim i As Long
    For i = LBound(dict, 1) To UBound(dict, 1)
        Dim key As String
        Dim value As Variant
        
        key = dict(i, 1)
        value = dict(i, 2)
        
        Select Case LCase(key)
            Case "status"
                If Not isFinal Then g_TaskStatus(taskId) = CStr(value)
            Case "progress"
                g_TaskProgress(taskId) = CDbl(value)
            Case "message"
                g_TaskMessage(taskId) = value
            Case "value"
                g_TaskValue(taskId) = value
            Case "write"
                ' 动态写入目标会在写入函数中处理
        End Select
    Next i
End Sub

' ============================================
' 第六部分：辅助函数（内部使用）
' ============================================
' 统一压栈函数 - 支持主状态机和协程线程
' L: 可以是 g_LuaState.L 或 coThread
Private Sub PushValue(ByVal L As LongPtr, ByVal value As Variant)
    ' 处理 Range 对象
    If TypeName(value) = "Range" Then
        Dim rng As Range
        Set rng = value
        If rng.Cells.Count = 1 Then
            ' 单个单元格，递归调用处理其值
            PushValue L, rng.value
        Else
            ' 多个单元格，获取数组后递归调用
            PushValue L, rng.value
        End If
        Exit Sub
    End If
    
    ' 处理数组
    If IsArray(value) Then
        PushArray L, value
        Exit Sub
    End If
    
    ' 处理基本类型
    If IsEmpty(value) Or IsNull(value) Then
        lua_pushnil L
    ElseIf IsNumeric(value) Then
        lua_pushnumber L, CDbl(value)
    ElseIf VarType(value) = vbBoolean Then
        lua_pushboolean L, IIf(value, 1, 0)
    Else
        lua_pushstring L, CStr(value)
    End If
End Sub

' 统一数组压栈函数 - 支持主状态机和协程线程
' L: 可以是 g_LuaState.L 或 coThread
Private Sub PushArray(ByVal L As LongPtr, arr As Variant)
    Dim i As Long, j As Long
    Dim rows As Long, cols As Long
    
    ' 处理一维数组
    On Error Resume Next
    rows = UBound(arr, 1) - LBound(arr, 1) + 1
    cols = UBound(arr, 2) - LBound(arr, 2) + 1
    
    If Err.Number <> 0 Then
        ' 一维数组
        Err.Clear
        On Error GoTo 0
        rows = UBound(arr) - LBound(arr) + 1
        
        lua_createtable L, rows, 0
        For i = LBound(arr) To UBound(arr)
            PushValue L, arr(i)  ' 递归调用 PushValue
            lua_rawseti L, -2, i - LBound(arr) + 1
        Next i
        Exit Sub
    End If
    On Error GoTo 0
    
    ' 二维数组
    lua_createtable L, rows, 0
    For i = LBound(arr, 1) To UBound(arr, 1)
        lua_createtable L, cols, 0
        For j = LBound(arr, 2) To UBound(arr, 2)
            PushValue L, arr(i, j)  ' 递归调用 PushValue
            lua_rawseti L, -2, j - LBound(arr, 2) + 1
        Next j
        lua_rawseti L, -2, i - LBound(arr, 1) + 1
    Next i
End Sub

' 从 Lua 栈获取字符串
Private Function GetStringFromState(ByVal L As LongPtr, ByVal idx As Long) As String
    Dim ptr As LongPtr
    Dim length As Long
    
    ptr = lua_tolstring(L, idx, VarPtr(length))
    If ptr = 0 Then
        GetStringFromState = ""
        Exit Function
    End If
    
    If length = 0 Then
        GetStringFromState = ""
        Exit Function
    End If
    
    ' 方案1：使用Windows API转换UTF-8
    GetStringFromState = UTF8ToVBAString(ptr, length)
End Function

' UTF8 to UTF16
Private Function UTF8ToVBAString(ByVal ptr As LongPtr, ByVal byteLen As Long) As String
    On Error GoTo ErrorHandler
    
    If ptr = 0 Or byteLen = 0 Then
        UTF8ToVBAString = ""
        Exit Function
    End If
    
    ' 复制字节到VBA数组
    Dim bytes() As Byte
    ReDim bytes(0 To byteLen - 1)
    CopyMemory bytes(0), ByVal ptr, byteLen
    
    ' 使用ADODB.Stream转换UTF-8
    Dim stream As Object
    Set stream = CreateObject("ADODB.Stream")
    
    stream.Type = 1 ' adTypeBinary
    stream.Open
    stream.Write bytes
    stream.Position = 0
    stream.Type = 2 ' adTypeText
    stream.Charset = "UTF-8"
    
    UTF8ToVBAString = stream.ReadText
    stream.Close
    
    Exit Function

ErrorHandler:
    UTF8ToVBAString = ""
    If Not stream Is Nothing Then
        On Error Resume Next
        stream.Close
    End If
End Function

' 从 Lua 栈获取值
Private Function GetValue(ByVal L As LongPtr, ByVal idx As Long) As Variant
    Dim luaType As Long
    luaType = lua_type(L, idx)
    
    Select Case luaType
        Case LUA_TNIL
            GetValue = Empty
        Case LUA_TBOOLEAN
            GetValue = (lua_toboolean(L, idx) <> 0)
        Case LUA_TNUMBER
            GetValue = lua_tonumberx(L, idx, 0)
        Case LUA_TSTRING
            GetValue = GetStringFromState(L, idx)
        Case LUA_TTABLE
            GetValue = TableToArray(L, idx)
        Case Else
            GetValue = "#LUA_TYPE_" & luaType
    End Select
End Function

' 将 Lua table 转换为二维数组
Private Function TableToArray(ByVal L As LongPtr, ByVal idx As Long) As Variant
    Dim rows As LongPtr, cols As LongPtr
    Dim i As Long, j As Long
    Dim arr() As Variant
    Dim isArray As Boolean
    
    rows = lua_rawlen(L, idx)
    
    If rows = 0 Then
        TableToArray = Empty
        Exit Function
    End If
    
    ' 检查第一个元素是否是表
    lua_rawgeti L, idx, 1
    isArray = (lua_type(L, -1) = LUA_TTABLE)
    
    If isArray Then
        ' 二维数组
        cols = lua_rawlen(L, -1)
        lua_settop L, -2
        
        ReDim arr(1 To CLng(rows), 1 To CLng(cols))
        
        For i = 1 To CLng(rows)
            lua_rawgeti L, idx, CLng(i)
            For j = 1 To CLng(cols)
                lua_rawgeti L, -1, CLng(j)
                arr(i, j) = GetValue(L, -1)
                lua_settop L, -2
            Next j
            lua_settop L, -2
        Next i
    Else
        ' 一维数组（转为单行二维数组）
        lua_settop L, -2
        ReDim arr(1 To 1, 1 To CLng(rows))
        
        For i = 1 To CLng(rows)
            lua_rawgeti L, idx, CLng(i)
            arr(1, i) = GetValue(L, -1)
            lua_settop L, -2
        Next i
    End If
    
    TableToArray = arr
End Function

' 根据调用单元格地址查找已存在的任务
Private Function FindTaskByCell(taskCell As String) As String
    Dim tid As Variant
    If g_TaskCell Is Nothing Then Exit Function

    For Each tid In g_TaskCell.Keys
        If g_TaskCell(tid) = taskCell Then
            FindTaskByCell = CStr(tid)
            Exit Function
        End If
    Next

    FindTaskByCell = ""
End Function
